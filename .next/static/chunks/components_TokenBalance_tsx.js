"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_TokenBalance_tsx"],{

/***/ "./node_modules/@solana/spl-token/lib/index.browser.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/spl-token/lib/index.browser.esm.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSOCIATED_TOKEN_PROGRAM_ID: function() { return /* binding */ ASSOCIATED_TOKEN_PROGRAM_ID; },\n/* harmony export */   AccountLayout: function() { return /* binding */ AccountLayout; },\n/* harmony export */   MintLayout: function() { return /* binding */ MintLayout; },\n/* harmony export */   NATIVE_MINT: function() { return /* binding */ NATIVE_MINT; },\n/* harmony export */   TOKEN_PROGRAM_ID: function() { return /* binding */ TOKEN_PROGRAM_ID; },\n/* harmony export */   Token: function() { return /* binding */ Token; },\n/* harmony export */   u64: function() { return /* binding */ u64; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n\n\n\n\nvar buffer = {};\n\nvar base64Js = {};\n\nbase64Js.byteLength = byteLength;\nbase64Js.toByteArray = toByteArray;\nbase64Js.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens (b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xFF;\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    );\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    );\n  }\n\n  return parts.join('')\n}\n\nvar ieee754 = {};\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\nieee754.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n};\n\nieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n(function (exports) {\n\nconst base64 = base64Js;\nconst ieee754$1 = ieee754;\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null;\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n\nconst K_MAX_LENGTH = 0x7fffffff;\nexports.kMaxLength = K_MAX_LENGTH;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  );\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1);\n    const proto = { foo: function () { return 42 } };\n    Object.setPrototypeOf(proto, Uint8Array.prototype);\n    Object.setPrototypeOf(arr, proto);\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n});\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n});\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length);\n  Object.setPrototypeOf(buf, Buffer.prototype);\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf();\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value);\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n};\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf(Buffer, Uint8Array);\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n};\n\nfunction allocUnsafe (size) {\n  assertSize(size);\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n};\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0;\n  let buf = createBuffer(length);\n\n  const actual = buf.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0;\n  const buf = createBuffer(length);\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255;\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView);\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf;\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array);\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset);\n  } else {\n    buf = new Uint8Array(array, byteOffset, length);\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype);\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0;\n    const buf = createBuffer(len);\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len);\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n};\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length;\n  let y = b.length;\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i];\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n        buf.copy(buffer, pos);\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        );\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos);\n    }\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n};\n\nBuffer.prototype.inspect = function inspect () {\n  let str = '';\n  const max = exports.INSPECT_MAX_BYTES;\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n  if (this.length > max) str += ' ... ';\n  return '<Buffer ' + str + '>'\n};\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength);\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart;\n  let y = end - start;\n  const len = Math.min(x, y);\n\n  const thisCopy = this.slice(thisStart, thisEnd);\n  const targetCopy = target.slice(start, end);\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset; // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1;\n  let arrLength = arr.length;\n  let valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i;\n  if (dir) {\n    let foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true;\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  const remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  const strLen = string.length;\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  let i;\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0;\n    if (isFinite(length)) {\n      length = length >>> 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  let loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  const res = [];\n\n  let i = start;\n  while (i < end) {\n    const firstByte = buf[i];\n    let codePoint = null;\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1;\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = '';\n  end = Math.min(buf.length, end);\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = '';\n  end = Math.min(buf.length, end);\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  let out = '';\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]];\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end);\n  let res = '';\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  const newBuf = this.subarray(start, end);\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype);\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  let val = this[offset];\n  let mul = 1;\n  let i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  let val = this[offset + --byteLength];\n  let mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n});\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n});\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  let val = this[offset];\n  let mul = 1;\n  let i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  let i = byteLength;\n  let mul = 1;\n  let val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  const val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  const val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n});\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n});\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754$1.read(this, offset, true, 23, 4)\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754$1.read(this, offset, false, 23, 4)\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754$1.read(this, offset, true, 52, 8)\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754$1.read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  let mul = 1;\n  let i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  let i = byteLength - 1;\n  let mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = (value & 0xff);\n  this[offset + 1] = (value >>> 8);\n  return offset + 2\n};\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = (value >>> 8);\n  this[offset + 1] = (value & 0xff);\n  return offset + 2\n};\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset + 3] = (value >>> 24);\n  this[offset + 2] = (value >>> 16);\n  this[offset + 1] = (value >>> 8);\n  this[offset] = (value & 0xff);\n  return offset + 4\n};\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset] = (value >>> 24);\n  this[offset + 1] = (value >>> 16);\n  this[offset + 2] = (value >>> 8);\n  this[offset + 3] = (value & 0xff);\n  return offset + 4\n};\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7);\n\n  let lo = Number(value & BigInt(0xffffffff));\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7);\n\n  let lo = Number(value & BigInt(0xffffffff));\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n});\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n});\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  let i = 0;\n  let mul = 1;\n  let sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  let i = byteLength - 1;\n  let mul = 1;\n  let sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = (value & 0xff);\n  this[offset + 1] = (value >>> 8);\n  return offset + 2\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = (value >>> 8);\n  this[offset + 1] = (value & 0xff);\n  return offset + 2\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = (value & 0xff);\n  this[offset + 1] = (value >>> 8);\n  this[offset + 2] = (value >>> 16);\n  this[offset + 3] = (value >>> 24);\n  return offset + 4\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  this[offset] = (value >>> 24);\n  this[offset + 1] = (value >>> 16);\n  this[offset + 2] = (value >>> 8);\n  this[offset + 3] = (value & 0xff);\n  return offset + 4\n};\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n});\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n});\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  const len = end - start;\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0);\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code;\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  } else if (typeof val === 'boolean') {\n    val = Number(val);\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  let i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding);\n    const len = bytes.length;\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {};\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super();\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      });\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`;\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack; // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name;\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      });\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  };\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError);\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError);\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received);\n      }\n      received += 'n';\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg\n  }, RangeError);\n\nfunction addNumericalSeparator (val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`;\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1));\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength);\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type);\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0];\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = [];\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo;\n  const byteArray = [];\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i;\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef';\n  const table = new Array(256);\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16;\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n  }\n  return table\n})();\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n}(buffer));\n\nvar global$1 = (typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g :\n  typeof self !== \"undefined\" ? self :\n  typeof window !== \"undefined\" ? window : {});\n\nvar inherits;\nif (typeof Object.create === 'function'){\n  inherits = function inherits(ctor, superCtor) {\n    // implementation from standard node.js 'util' module\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  inherits = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}\nvar inherits$1 = inherits;\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect$1(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    _extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect$1.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect$1.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect$1.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect$1.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect$1.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== inspect$1 &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var length = output.reduce(function(prev, cur) {\n    if (cur.indexOf('\\n') >= 0) ;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction _extend(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n}\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\nvar pSlice = Array.prototype.slice;\nvar _functionsHaveNames;\nfunction functionsHaveNames() {\n  if (typeof _functionsHaveNames !== 'undefined') {\n    return _functionsHaveNames;\n  }\n  return _functionsHaveNames = (function () {\n    return function foo() {}.name === 'foo';\n  }());\n}\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (buffer.isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global$1.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nfunction assert(value, message) {\n  if (!value) fail(value, true, message, '==', ok);\n}\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames()) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = AssertionError;\nfunction AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n}\n\n// assert.AssertionError instanceof Error\ninherits$1(AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames() || !isFunction(something)) {\n    return inspect$1(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\nassert.equal = equal;\nfunction equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', equal);\n}\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\nassert.notEqual = notEqual;\nfunction notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', notEqual);\n  }\n}\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\nassert.deepEqual = deepEqual;\nfunction deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', deepEqual);\n  }\n}\nassert.deepStrictEqual = deepStrictEqual;\nfunction deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);\n  }\n}\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (buffer.isBuffer(actual) && buffer.isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (isDate(actual) && isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (isRegExp(actual) && isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (buffer.isBuffer(actual) !== buffer.isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (isPrimitive(a) || isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\nassert.notDeepEqual = notDeepEqual;\nfunction notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);\n  }\n}\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\nassert.strictEqual = strictEqual;\nfunction strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', strictEqual);\n  }\n}\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\nassert.notStrictEqual = notStrictEqual;\nfunction notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', notStrictEqual);\n  }\n}\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\nassert.throws = throws;\nfunction throws(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n}\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = doesNotThrow;\nfunction doesNotThrow(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n}\n\nassert.ifError = ifError;\nfunction ifError(err) {\n  if (err) throw err;\n}\n\nvar Layout$1 = {};\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nLayout$1.Layout = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nLayout$1.nameWithProperty = nameWithProperty;\n\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && (layout instanceof Layout))) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = (() => new Class());\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true,\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true,\n  });\n}\nLayout$1.bindConstructorLayout = bindConstructorLayout;\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\n\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan, property) {\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n    if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n\n  /** @override */\n  isCount() {\n    return true;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\n\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    this.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    this.offset = offset;\n  }\n\n  /** @override */\n  isCount() {\n    return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.decode(b, offset + this.offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\n\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super( span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\nconst V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - (hi32 * V2E32);\n  return {hi32, lo32};\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readUInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatLE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatBE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleLE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleBE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(((count instanceof ExternalLayout) && count.isCount())\n          || (Number.isInteger(count) && (0 <= count)))) {\n      throw new TypeError('count must be non-negative integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if ((!(count instanceof ExternalLayout))\n        && (0 < elementLayout.span)) {\n      span = count * elementLayout.span;\n    }\n\n    super(span, property);\n\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields)\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if (('boolean' === typeof property)\n        && (undefined === decodePrefixes)) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if ((0 > fd.span)\n          && (undefined === fd.property)) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n    }\n    super(span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes\n          && (b.length === offset)) {\n        break;\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = (0 < span) ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return (lastOffset + lastWrote) - firstOffset;\n  }\n\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if ((undefined !== fd.property)\n          && (0 < values.length)) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n}\n\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\n\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!((layout instanceof ExternalLayout)\n          && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\n\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = ((discr instanceof UInt)\n               || (discr instanceof UIntBE));\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if ((discr instanceof ExternalLayout)\n               && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator '\n                          + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!((null === defaultLayout)\n          || (defaultLayout instanceof Layout))) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if ((0 <= span) && upv) {\n        span += discr.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function(src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function(gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout\n          && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo\n          && ((!vlo.layout)\n              || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b,\n                                        offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset) {\n    let variant = vb;\n    if (buffer.Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      variant = this.discriminator.decode(vb, offset);\n    }\n    return this.registry[variant];\n  }\n}\n\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if (('string' === typeof layout)\n        && (undefined === property)) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if ((null !== union.defaultLayout)\n          && (0 <= layout.span)\n          && (layout.span > union.defaultLayout.span)) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout\n        && (!src.hasOwnProperty(this.property))) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if ((0 <= this.union.span)\n          && (span > this.union.span)) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n}\n\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!((word instanceof UInt)\n          || (word instanceof UIntBE))) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if (('string' === typeof msb)\n        && (undefined === property)) {\n      property = msb;\n      msb = undefined;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    this.word = word;\n\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    this.fields = [];\n\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function(v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function() {\n      return value;\n    };\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n}\n\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if ((!Number.isInteger(bits)) || (0 >= bits)) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if ((bits + usedBits) > totalBits) {\n      throw new Error('bits too long for span remainder ('\n                      + (totalBits - usedBits) + ' of '\n                      + totalBits + ' remain)');\n    }\n\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n\n    /** The span of this value in bits. */\n    this.bits = bits;\n\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) { // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  decode() {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ((!Number.isInteger(value))\n        || (value !== fixBitwiseResult(value & this.valueMask))) {\n      throw new TypeError(nameWithProperty('BitField.encode', this)\n                          + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n                                   | wordValue);\n  };\n}\n\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  }\n\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    return BitField.prototype.encode.call(this, value);\n  }\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(((length instanceof ExternalLayout) && length.isCount())\n          || (Number.isInteger(length) && (0 <= length)))) {\n      throw new TypeError('length must be positive integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return b.slice(offset, offset + span);\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(buffer.Buffer.isBuffer(src)\n          && (span === src.length))) {\n      throw new TypeError(nameWithProperty('Blob.encode', this)\n                          + ' requires (length ' + span + ') Buffer as src');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    b.write(src.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!buffer.Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let idx = offset;\n    while ((idx < b.length) && (0 !== b[idx])) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    return b.slice(offset, offset + span - 1).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new buffer.Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    b[offset + span] = 0;\n    return span + 1;\n  }\n}\n\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if (('string' === typeof maxSpan)\n        && (undefined === property)) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    super(-1, property);\n\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!buffer.Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.length - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return b.slice(offset, offset + span).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new buffer.Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    return span;\n  }\n}\n\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    this.value = value;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    return this.value;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\n\nLayout$1.ExternalLayout = ExternalLayout;\nLayout$1.GreedyCount = GreedyCount;\nLayout$1.OffsetLayout = OffsetLayout;\nLayout$1.UInt = UInt;\nLayout$1.UIntBE = UIntBE;\nLayout$1.Int = Int;\nLayout$1.IntBE = IntBE;\nLayout$1.Float = Float;\nLayout$1.FloatBE = FloatBE;\nLayout$1.Double = Double;\nLayout$1.DoubleBE = DoubleBE;\nLayout$1.Sequence = Sequence;\nLayout$1.Structure = Structure;\nLayout$1.UnionDiscriminator = UnionDiscriminator;\nLayout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nLayout$1.Union = Union;\nLayout$1.VariantLayout = VariantLayout;\nLayout$1.BitStructure = BitStructure;\nLayout$1.BitField = BitField;\nLayout$1.Boolean = Boolean;\nLayout$1.Blob = Blob;\nLayout$1.CString = CString;\nLayout$1.UTF8 = UTF8;\nLayout$1.Constant = Constant;\n\n/** Factory for {@link GreedyCount}. */\nLayout$1.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n\n/** Factory for {@link OffsetLayout}. */\nLayout$1.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nvar u8 = Layout$1.u8 = (property => new UInt(1, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nLayout$1.u16 = (property => new UInt(2, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nLayout$1.u24 = (property => new UInt(3, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nvar u32 = Layout$1.u32 = (property => new UInt(4, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nLayout$1.u40 = (property => new UInt(5, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nLayout$1.u48 = (property => new UInt(6, property));\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nLayout$1.nu64 = (property => new NearUInt64(property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nLayout$1.u16be = (property => new UIntBE(2, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nLayout$1.u24be = (property => new UIntBE(3, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nLayout$1.u32be = (property => new UIntBE(4, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nLayout$1.u40be = (property => new UIntBE(5, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nLayout$1.u48be = (property => new UIntBE(6, property));\n\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nLayout$1.nu64be = (property => new NearUInt64BE(property));\n\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nLayout$1.s8 = (property => new Int(1, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nLayout$1.s16 = (property => new Int(2, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nLayout$1.s24 = (property => new Int(3, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nLayout$1.s32 = (property => new Int(4, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nLayout$1.s40 = (property => new Int(5, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nLayout$1.s48 = (property => new Int(6, property));\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nLayout$1.ns64 = (property => new NearInt64(property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nLayout$1.s16be = (property => new IntBE(2, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nLayout$1.s24be = (property => new IntBE(3, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nLayout$1.s32be = (property => new IntBE(4, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nLayout$1.s40be = (property => new IntBE(5, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nLayout$1.s48be = (property => new IntBE(6, property));\n\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nLayout$1.ns64be = (property => new NearInt64BE(property));\n\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nLayout$1.f32 = (property => new Float(property));\n\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nLayout$1.f32be = (property => new FloatBE(property));\n\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nLayout$1.f64 = (property => new Double(property));\n\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nLayout$1.f64be = (property => new DoubleBE(property));\n\n/** Factory for {@link Structure} values. */\nvar struct = Layout$1.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n\n/** Factory for {@link BitStructure} values. */\nLayout$1.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n\n/** Factory for {@link Sequence} values. */\nLayout$1.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n\n/** Factory for {@link Union} values. */\nLayout$1.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nLayout$1.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n\n/** Factory for {@link Blob} values. */\nvar blob = Layout$1.blob = ((length, property) => new Blob(length, property));\n\n/** Factory for {@link CString} values. */\nLayout$1.cstr = (property => new CString(property));\n\n/** Factory for {@link UTF8} values. */\nLayout$1.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n\n/** Factory for {@link Constant} values. */\nLayout$1.const = ((value, property) => new Constant(value, property));\n\n//      \n/**\n * Layout for a public key\n */\n\nconst publicKey = (property = 'publicKey') => {\n  return blob(32, property);\n};\n/**\n * Layout for a 64bit unsigned value\n */\n\nconst uint64 = (property = 'uint64') => {\n  return blob(8, property);\n};\n\n//      \nfunction sendAndConfirmTransaction(title, connection, transaction, ...signers) {\n  return (0,_solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.sendAndConfirmTransaction)(connection, transaction, signers, {\n    skipPreflight: false\n  });\n}\n\nconst TOKEN_PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\nconst ASSOCIATED_TOKEN_PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\nconst FAILED_TO_FIND_ACCOUNT = 'Failed to find account';\nconst INVALID_ACCOUNT_OWNER = 'Invalid account owner';\n/**\n * Unfortunately, BufferLayout.encode uses an `instanceof` check for `Buffer`\n * which fails when using `publicKey.toBuffer()` directly because the bundled `Buffer`\n * class in `@solana/web3.js` is different from the bundled `Buffer` class in this package\n */\n\nfunction pubkeyToBuffer(publicKey) {\n  return buffer.Buffer.from(publicKey.toBuffer());\n}\n/**\n * 64-bit value\n */\n\n\nclass u64 extends (bn_js__WEBPACK_IMPORTED_MODULE_1___default()) {\n  /**\n   * Convert to Buffer representation\n   */\n  toBuffer() {\n    const a = super.toArray().reverse();\n    const b = buffer.Buffer.from(a);\n\n    if (b.length === 8) {\n      return b;\n    }\n\n    assert(b.length < 8, 'u64 too large');\n    const zeroPad = buffer.Buffer.alloc(8);\n    b.copy(zeroPad);\n    return zeroPad;\n  }\n  /**\n   * Construct a u64 from Buffer representation\n   */\n\n\n  static fromBuffer(buffer) {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new u64([...buffer].reverse().map(i => `00${i.toString(16)}`.slice(-2)).join(''), 16);\n  }\n\n}\n\nfunction isAccount(accountOrPublicKey) {\n  return 'publicKey' in accountOrPublicKey;\n}\n\nconst AuthorityTypeCodes = {\n  MintTokens: 0,\n  FreezeAccount: 1,\n  AccountOwner: 2,\n  CloseAccount: 3\n}; // The address of the special mint for wrapped native token.\n\nconst NATIVE_MINT = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey('So11111111111111111111111111111111111111112');\n/**\n * Information about the mint\n */\n\nconst MintLayout = struct([u32('mintAuthorityOption'), publicKey('mintAuthority'), uint64('supply'), u8('decimals'), u8('isInitialized'), u32('freezeAuthorityOption'), publicKey('freezeAuthority')]);\n/**\n * Information about an account\n */\n\n/**\n * @private\n */\n\nconst AccountLayout = struct([publicKey('mint'), publicKey('owner'), uint64('amount'), u32('delegateOption'), publicKey('delegate'), u8('state'), u32('isNativeOption'), uint64('isNative'), uint64('delegatedAmount'), u32('closeAuthorityOption'), publicKey('closeAuthority')]);\n/**\n * Information about an multisig\n */\n\n/**\n * @private\n */\n\nconst MultisigLayout = struct([u8('m'), u8('n'), u8('is_initialized'), publicKey('signer1'), publicKey('signer2'), publicKey('signer3'), publicKey('signer4'), publicKey('signer5'), publicKey('signer6'), publicKey('signer7'), publicKey('signer8'), publicKey('signer9'), publicKey('signer10'), publicKey('signer11')]);\n/**\n * An ERC20-like Token\n */\n\nclass Token {\n  /**\n   * @private\n   */\n\n  /**\n   * The public key identifying this mint\n   */\n\n  /**\n   * Program Identifier for the Token program\n   */\n\n  /**\n   * Program Identifier for the Associated Token program\n   */\n\n  /**\n   * Fee payer\n   */\n\n  /**\n   * Create a Token object attached to the specific mint\n   *\n   * @param connection The connection to use\n   * @param token Public key of the mint\n   * @param programId token programId\n   * @param payer Payer of fees\n   */\n  constructor(connection, publicKey, programId, payer) {\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"connection\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"publicKey\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"programId\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"associatedProgramId\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"payer\", void 0);\n\n    Object.assign(this, {\n      connection,\n      publicKey,\n      programId,\n      payer,\n      // Hard code is ok; Overriding is needed only for tests\n      associatedProgramId: ASSOCIATED_TOKEN_PROGRAM_ID\n    });\n  }\n  /**\n   * Get the minimum balance for the mint to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  static async getMinBalanceRentForExemptMint(connection) {\n    return await connection.getMinimumBalanceForRentExemption(MintLayout.span);\n  }\n  /**\n   * Get the minimum balance for the account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  static async getMinBalanceRentForExemptAccount(connection) {\n    return await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  }\n  /**\n   * Get the minimum balance for the multsig to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  static async getMinBalanceRentForExemptMultisig(connection) {\n    return await connection.getMinimumBalanceForRentExemption(MultisigLayout.span);\n  }\n  /**\n   * Create and initialize a token.\n   *\n   * @param connection The connection to use\n   * @param payer Fee payer for transaction\n   * @param mintAuthority Account or multisig that will control minting\n   * @param freezeAuthority Optional account or multisig that can freeze token accounts\n   * @param decimals Location of the decimal place\n   * @param programId Optional token programId, uses the system programId by default\n   * @return Token object for the newly minted token\n   */\n\n\n  static async createMint(connection, payer, mintAuthority, freezeAuthority, decimals, programId) {\n    const mintAccount = _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Keypair.generate();\n    const token = new Token(connection, mintAccount.publicKey, programId, payer); // Allocate memory for the account\n\n    const balanceNeeded = await Token.getMinBalanceRentForExemptMint(connection);\n    const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction();\n    transaction.add(_solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SystemProgram.createAccount({\n      fromPubkey: payer.publicKey,\n      newAccountPubkey: mintAccount.publicKey,\n      lamports: balanceNeeded,\n      space: MintLayout.span,\n      programId\n    }));\n    transaction.add(Token.createInitMintInstruction(programId, mintAccount.publicKey, decimals, mintAuthority, freezeAuthority)); // Send the two instructions\n\n    await sendAndConfirmTransaction('createAccount and InitializeMint', connection, transaction, payer, mintAccount);\n    return token;\n  }\n  /**\n   * Create and initialize a new account.\n   *\n   * This account may then be used as a `transfer()` or `approve()` destination\n   *\n   * @param owner User account that will own the new account\n   * @return Public key of the new empty account\n   */\n\n\n  async createAccount(owner) {\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(this.connection);\n    const newAccount = _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Keypair.generate();\n    const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction();\n    transaction.add(_solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SystemProgram.createAccount({\n      fromPubkey: this.payer.publicKey,\n      newAccountPubkey: newAccount.publicKey,\n      lamports: balanceNeeded,\n      space: AccountLayout.span,\n      programId: this.programId\n    }));\n    const mintPublicKey = this.publicKey;\n    transaction.add(Token.createInitAccountInstruction(this.programId, mintPublicKey, newAccount.publicKey, owner)); // Send the two instructions\n\n    await sendAndConfirmTransaction('createAccount and InitializeAccount', this.connection, transaction, this.payer, newAccount);\n    return newAccount.publicKey;\n  }\n  /**\n   * Create and initialize the associated account.\n   *\n   * This account may then be used as a `transfer()` or `approve()` destination\n   *\n   * @param owner User account that will own the new account\n   * @return Public key of the new associated account\n   */\n\n\n  async createAssociatedTokenAccount(owner) {\n    const associatedAddress = await Token.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, owner);\n    return this.createAssociatedTokenAccountInternal(owner, associatedAddress);\n  }\n\n  async createAssociatedTokenAccountInternal(owner, associatedAddress) {\n    await sendAndConfirmTransaction('CreateAssociatedTokenAccount', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createAssociatedTokenAccountInstruction(this.associatedProgramId, this.programId, this.publicKey, associatedAddress, owner, this.payer.publicKey)), this.payer);\n    return associatedAddress;\n  }\n  /**\n   * Retrieve the associated account or create one if not found.\n   *\n   * This account may then be used as a `transfer()` or `approve()` destination\n   *\n   * @param owner User account that will own the new account\n   * @return The new associated account\n   */\n\n\n  async getOrCreateAssociatedAccountInfo(owner) {\n    const associatedAddress = await Token.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, owner); // This is the optimum logic, considering TX fee, client-side computation,\n    // RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically;\n\n    try {\n      return await this.getAccountInfo(associatedAddress);\n    } catch (err) {\n      // INVALID_ACCOUNT_OWNER can be possible if the associatedAddress has\n      // already been received some lamports (= became system accounts).\n      // Assuming program derived addressing is safe, this is the only case\n      // for the INVALID_ACCOUNT_OWNER in this code-path\n      if (err.message === FAILED_TO_FIND_ACCOUNT || err.message === INVALID_ACCOUNT_OWNER) {\n        // as this isn't atomic, it's possible others can create associated\n        // accounts meanwhile\n        try {\n          await this.createAssociatedTokenAccountInternal(owner, associatedAddress);\n        } catch (err) {// ignore all errors; for now there is no API compatible way to\n          // selectively ignore the expected instruction error if the\n          // associated account is existing already.\n        } // Now this should always succeed\n\n\n        return await this.getAccountInfo(associatedAddress);\n      } else {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Create and initialize a new account on the special native token mint.\n   *\n   * In order to be wrapped, the account must have a balance of native tokens\n   * when it is initialized with the token program.\n   *\n   * This function sends lamports to the new account before initializing it.\n   *\n   * @param connection A solana web3 connection\n   * @param programId The token program ID\n   * @param owner The owner of the new token account\n   * @param payer The source of the lamports to initialize, and payer of the initialization fees.\n   * @param amount The amount of lamports to wrap\n   * @return {Promise<PublicKey>} The new token account\n   */\n\n\n  static async createWrappedNativeAccount(connection, programId, owner, payer, amount) {\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(connection); // Create a new account\n\n    const newAccount = _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Keypair.generate();\n    const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction();\n    transaction.add(_solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SystemProgram.createAccount({\n      fromPubkey: payer.publicKey,\n      newAccountPubkey: newAccount.publicKey,\n      lamports: balanceNeeded,\n      space: AccountLayout.span,\n      programId\n    })); // Send lamports to it (these will be wrapped into native tokens by the token program)\n\n    transaction.add(_solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: newAccount.publicKey,\n      lamports: amount\n    })); // Assign the new account to the native token mint.\n    // the account will be initialized with a balance equal to the native token balance.\n    // (i.e. amount)\n\n    transaction.add(Token.createInitAccountInstruction(programId, NATIVE_MINT, newAccount.publicKey, owner)); // Send the three instructions\n\n    await sendAndConfirmTransaction('createAccount, transfer, and initializeAccount', connection, transaction, payer, newAccount);\n    return newAccount.publicKey;\n  }\n  /**\n   * Create and initialize a new multisig.\n   *\n   * This account may then be used for multisignature verification\n   *\n   * @param m Number of required signatures\n   * @param signers Full set of signers\n   * @return Public key of the new multisig account\n   */\n\n\n  async createMultisig(m, signers) {\n    const multisigAccount = _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Keypair.generate(); // Allocate memory for the account\n\n    const balanceNeeded = await Token.getMinBalanceRentForExemptMultisig(this.connection);\n    const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction();\n    transaction.add(_solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SystemProgram.createAccount({\n      fromPubkey: this.payer.publicKey,\n      newAccountPubkey: multisigAccount.publicKey,\n      lamports: balanceNeeded,\n      space: MultisigLayout.span,\n      programId: this.programId\n    })); // create the new account\n\n    let keys = [{\n      pubkey: multisigAccount.publicKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    signers.forEach(signer => keys.push({\n      pubkey: signer,\n      isSigner: false,\n      isWritable: false\n    }));\n    const dataLayout = struct([u8('instruction'), u8('m')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 2,\n      // InitializeMultisig instruction\n      m\n    }, data);\n    transaction.add({\n      keys,\n      programId: this.programId,\n      data\n    }); // Send the two instructions\n\n    await sendAndConfirmTransaction('createAccount and InitializeMultisig', this.connection, transaction, this.payer, multisigAccount);\n    return multisigAccount.publicKey;\n  }\n  /**\n   * Retrieve mint information\n   */\n\n\n  async getMintInfo() {\n    const info = await this.connection.getAccountInfo(this.publicKey);\n\n    if (info === null) {\n      throw new Error('Failed to find mint account');\n    }\n\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid mint owner: ${JSON.stringify(info.owner)}`);\n    }\n\n    if (info.data.length != MintLayout.span) {\n      throw new Error(`Invalid mint size`);\n    }\n\n    const data = buffer.Buffer.from(info.data);\n    const mintInfo = MintLayout.decode(data);\n\n    if (mintInfo.mintAuthorityOption === 0) {\n      mintInfo.mintAuthority = null;\n    } else {\n      mintInfo.mintAuthority = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(mintInfo.mintAuthority);\n    }\n\n    mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n    mintInfo.isInitialized = mintInfo.isInitialized != 0;\n\n    if (mintInfo.freezeAuthorityOption === 0) {\n      mintInfo.freezeAuthority = null;\n    } else {\n      mintInfo.freezeAuthority = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(mintInfo.freezeAuthority);\n    }\n\n    return mintInfo;\n  }\n  /**\n   * Retrieve account information\n   *\n   * @param account Public key of the account\n   */\n\n\n  async getAccountInfo(account, commitment) {\n    const info = await this.connection.getAccountInfo(account, commitment);\n\n    if (info === null) {\n      throw new Error(FAILED_TO_FIND_ACCOUNT);\n    }\n\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(INVALID_ACCOUNT_OWNER);\n    }\n\n    if (info.data.length != AccountLayout.span) {\n      throw new Error(`Invalid account size`);\n    }\n\n    const data = buffer.Buffer.from(info.data);\n    const accountInfo = AccountLayout.decode(data);\n    accountInfo.address = account;\n    accountInfo.mint = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(accountInfo.mint);\n    accountInfo.owner = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(accountInfo.owner);\n    accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n    if (accountInfo.delegateOption === 0) {\n      accountInfo.delegate = null;\n      accountInfo.delegatedAmount = new u64();\n    } else {\n      accountInfo.delegate = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(accountInfo.delegate);\n      accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n    }\n\n    accountInfo.isInitialized = accountInfo.state !== 0;\n    accountInfo.isFrozen = accountInfo.state === 2;\n\n    if (accountInfo.isNativeOption === 1) {\n      accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n      accountInfo.isNative = true;\n    } else {\n      accountInfo.rentExemptReserve = null;\n      accountInfo.isNative = false;\n    }\n\n    if (accountInfo.closeAuthorityOption === 0) {\n      accountInfo.closeAuthority = null;\n    } else {\n      accountInfo.closeAuthority = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(accountInfo.closeAuthority);\n    }\n\n    if (!accountInfo.mint.equals(this.publicKey)) {\n      throw new Error(`Invalid account mint: ${JSON.stringify(accountInfo.mint)} !== ${JSON.stringify(this.publicKey)}`);\n    }\n\n    return accountInfo;\n  }\n  /**\n   * Retrieve Multisig information\n   *\n   * @param multisig Public key of the account\n   */\n\n\n  async getMultisigInfo(multisig) {\n    const info = await this.connection.getAccountInfo(multisig);\n\n    if (info === null) {\n      throw new Error('Failed to find multisig');\n    }\n\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid multisig owner`);\n    }\n\n    if (info.data.length != MultisigLayout.span) {\n      throw new Error(`Invalid multisig size`);\n    }\n\n    const data = buffer.Buffer.from(info.data);\n    const multisigInfo = MultisigLayout.decode(data);\n    multisigInfo.signer1 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer1);\n    multisigInfo.signer2 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer2);\n    multisigInfo.signer3 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer3);\n    multisigInfo.signer4 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer4);\n    multisigInfo.signer5 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer5);\n    multisigInfo.signer6 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer6);\n    multisigInfo.signer7 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer7);\n    multisigInfo.signer8 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer8);\n    multisigInfo.signer9 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer9);\n    multisigInfo.signer10 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer10);\n    multisigInfo.signer11 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(multisigInfo.signer11);\n    return multisigInfo;\n  }\n  /**\n   * Transfer tokens to another account\n   *\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Number of tokens to transfer\n   */\n\n\n  async transfer(source, destination, owner, multiSigners, amount) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    return await sendAndConfirmTransaction('Transfer', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createTransferInstruction(this.programId, source, destination, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);\n  }\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account\n   *\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n\n\n  async approve(account, delegate, owner, multiSigners, amount) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('Approve', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createApproveInstruction(this.programId, account, delegate, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);\n  }\n  /**\n   * Remove approval for the transfer of any remaining tokens\n   *\n   * @param account Public key of the account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  async revoke(account, owner, multiSigners) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('Revoke', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createRevokeInstruction(this.programId, account, ownerPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Assign a new authority to the account\n   *\n   * @param account Public key of the account\n   * @param newAuthority New authority of the account\n   * @param authorityType Type of authority to set\n   * @param currentAuthority Current authority of the account\n   * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n   */\n\n\n  async setAuthority(account, newAuthority, authorityType, currentAuthority, multiSigners) {\n    let currentAuthorityPublicKey;\n    let signers;\n\n    if (isAccount(currentAuthority)) {\n      currentAuthorityPublicKey = currentAuthority.publicKey;\n      signers = [currentAuthority];\n    } else {\n      currentAuthorityPublicKey = currentAuthority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('SetAuthority', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createSetAuthorityInstruction(this.programId, account, newAuthority, authorityType, currentAuthorityPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Mint new tokens\n   *\n   * @param dest Public key of the account to mint to\n   * @param authority Minting authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   */\n\n\n  async mintTo(dest, authority, multiSigners, amount) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      ownerPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      ownerPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('MintTo', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createMintToInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);\n  }\n  /**\n   * Burn tokens\n   *\n   * @param account Account to burn tokens from\n   * @param owner Account owner\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Amount to burn\n   */\n\n\n  async burn(account, owner, multiSigners, amount) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('Burn', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createBurnInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);\n  }\n  /**\n   * Close account\n   *\n   * @param account Account to close\n   * @param dest Account to receive the remaining balance of the closed account\n   * @param authority Authority which is allowed to close the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n\n\n  async closeAccount(account, dest, authority, multiSigners) {\n    let authorityPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('CloseAccount', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createCloseAccountInstruction(this.programId, account, dest, authorityPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Freeze account\n   *\n   * @param account Account to freeze\n   * @param authority The mint freeze authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n\n\n  async freezeAccount(account, authority, multiSigners) {\n    let authorityPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('FreezeAccount', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createFreezeAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Thaw account\n   *\n   * @param account Account to thaw\n   * @param authority The mint freeze authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n\n\n  async thawAccount(account, authority, multiSigners) {\n    let authorityPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('ThawAccount', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createThawAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Transfer tokens to another account, asserting the token mint and decimals\n   *\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Number of tokens to transfer\n   * @param decimals Number of decimals in transfer amount\n   */\n\n\n  async transferChecked(source, destination, owner, multiSigners, amount, decimals) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    return await sendAndConfirmTransaction('TransferChecked', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createTransferCheckedInstruction(this.programId, source, this.publicKey, destination, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);\n  }\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account,\n   * asserting the token mint and decimals\n   *\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   * @param decimals Number of decimals in approve amount\n   */\n\n\n  async approveChecked(account, delegate, owner, multiSigners, amount, decimals) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('ApproveChecked', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createApproveCheckedInstruction(this.programId, account, this.publicKey, delegate, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);\n  }\n  /**\n   * Mint new tokens, asserting the token mint and decimals\n   *\n   * @param dest Public key of the account to mint to\n   * @param authority Minting authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   * @param decimals Number of decimals in amount to mint\n   */\n\n\n  async mintToChecked(dest, authority, multiSigners, amount, decimals) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      ownerPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      ownerPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('MintToChecked', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createMintToCheckedInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);\n  }\n  /**\n   * Burn tokens, asserting the token mint and decimals\n   *\n   * @param account Account to burn tokens from\n   * @param owner Account owner\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Amount to burn\n   * @param decimals Number of decimals in amount to burn\n   */\n\n\n  async burnChecked(account, owner, multiSigners, amount, decimals) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('BurnChecked', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createBurnCheckedInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);\n  }\n  /**\n   * Sync amount in native SPL token account to underlying lamports\n   *\n   * @param nativeAccount Account to sync\n   */\n\n\n  async syncNative(nativeAccount) {\n    await sendAndConfirmTransaction('SyncNative', this.connection, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.Transaction().add(Token.createSyncNativeInstruction(this.programId, nativeAccount)), this.payer);\n  }\n  /**\n   * Construct an InitializeMint instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param decimals Number of decimals in token account amounts\n   * @param mintAuthority Minting authority\n   * @param freezeAuthority Optional authority that can freeze token accounts\n   */\n\n\n  static createInitMintInstruction(programId, mint, decimals, mintAuthority, freezeAuthority) {\n    let keys = [{\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    const commandDataLayout = struct([u8('instruction'), u8('decimals'), publicKey('mintAuthority'), u8('option'), publicKey('freezeAuthority')]);\n    let data = buffer.Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode({\n        instruction: 0,\n        // InitializeMint instruction\n        decimals,\n        mintAuthority: pubkeyToBuffer(mintAuthority),\n        option: freezeAuthority === null ? 0 : 1,\n        freezeAuthority: pubkeyToBuffer(freezeAuthority || new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(0))\n      }, data);\n      data = data.slice(0, encodeLength);\n    }\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId,\n      data\n    });\n  }\n  /**\n   * Construct an InitializeAccount instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param account New account\n   * @param owner Owner of the new account\n   */\n\n\n  static createInitAccountInstruction(programId, mint, account, owner) {\n    const keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: owner,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    const dataLayout = struct([u8('instruction')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 1 // InitializeAccount instruction\n\n    }, data);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId,\n      data\n    });\n  }\n  /**\n   * Construct a Transfer instruction\n   *\n   * @param programId SPL Token program account\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Number of tokens to transfer\n   */\n\n\n  static createTransferInstruction(programId, source, destination, owner, multiSigners, amount) {\n    const dataLayout = struct([u8('instruction'), uint64('amount')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 3,\n      // Transfer instruction\n      amount: new u64(amount).toBuffer()\n    }, data);\n    let keys = [{\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: destination,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct an Approve instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer of tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n\n\n  static createApproveInstruction(programId, account, delegate, owner, multiSigners, amount) {\n    const dataLayout = struct([u8('instruction'), uint64('amount')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 4,\n      // Approve instruction\n      amount: new u64(amount).toBuffer()\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: delegate,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Revoke instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  static createRevokeInstruction(programId, account, owner, multiSigners) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 5 // Approve instruction\n\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a SetAuthority instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param newAuthority New authority of the account\n   * @param authorityType Type of authority to set\n   * @param currentAuthority Current authority of the specified type\n   * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n   */\n\n\n  static createSetAuthorityInstruction(programId, account, newAuthority, authorityType, currentAuthority, multiSigners) {\n    const commandDataLayout = struct([u8('instruction'), u8('authorityType'), u8('option'), publicKey('newAuthority')]);\n    let data = buffer.Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode({\n        instruction: 6,\n        // SetAuthority instruction\n        authorityType: AuthorityTypeCodes[authorityType],\n        option: newAuthority === null ? 0 : 1,\n        newAuthority: pubkeyToBuffer(newAuthority || new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(0))\n      }, data);\n      data = data.slice(0, encodeLength);\n    }\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: currentAuthority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: currentAuthority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a MintTo instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Public key of the mint\n   * @param dest Public key of the account to mint to\n   * @param authority The mint authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   */\n\n\n  static createMintToInstruction(programId, mint, dest, authority, multiSigners, amount) {\n    const dataLayout = struct([u8('instruction'), uint64('amount')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 7,\n      // MintTo instruction\n      amount: new u64(amount).toBuffer()\n    }, data);\n    let keys = [{\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: dest,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Burn instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Mint for the account\n   * @param account Account to burn tokens from\n   * @param owner Owner of the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount amount to burn\n   */\n\n\n  static createBurnInstruction(programId, mint, account, owner, multiSigners, amount) {\n    const dataLayout = struct([u8('instruction'), uint64('amount')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 8,\n      // Burn instruction\n      amount: new u64(amount).toBuffer()\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Close instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to close\n   * @param dest Account to receive the remaining balance of the closed account\n   * @param authority Account Close authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  static createCloseAccountInstruction(programId, account, dest, owner, multiSigners) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 9 // CloseAccount instruction\n\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: dest,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Freeze instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to freeze\n   * @param mint Mint account\n   * @param authority Mint freeze authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  static createFreezeAccountInstruction(programId, account, mint, authority, multiSigners) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 10 // FreezeAccount instruction\n\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Thaw instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to thaw\n   * @param mint Mint account\n   * @param authority Mint freeze authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  static createThawAccountInstruction(programId, account, mint, authority, multiSigners) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 11 // ThawAccount instruction\n\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a TransferChecked instruction\n   *\n   * @param programId SPL Token program account\n   * @param source Source account\n   * @param mint Mint account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Number of tokens to transfer\n   * @param decimals Number of decimals in transfer amount\n   */\n\n\n  static createTransferCheckedInstruction(programId, source, mint, destination, owner, multiSigners, amount, decimals) {\n    const dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 12,\n      // TransferChecked instruction\n      amount: new u64(amount).toBuffer(),\n      decimals\n    }, data);\n    let keys = [{\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: destination,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct an ApproveChecked instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param mint Mint account\n   * @param delegate Account authorized to perform a transfer of tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   * @param decimals Number of decimals in approve amount\n   */\n\n\n  static createApproveCheckedInstruction(programId, account, mint, delegate, owner, multiSigners, amount, decimals) {\n    const dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 13,\n      // ApproveChecked instruction\n      amount: new u64(amount).toBuffer(),\n      decimals\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: delegate,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a MintToChecked instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Public key of the mint\n   * @param dest Public key of the account to mint to\n   * @param authority The mint authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   * @param decimals Number of decimals in amount to mint\n   */\n\n\n  static createMintToCheckedInstruction(programId, mint, dest, authority, multiSigners, amount, decimals) {\n    const dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 14,\n      // MintToChecked instruction\n      amount: new u64(amount).toBuffer(),\n      decimals\n    }, data);\n    let keys = [{\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: dest,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a BurnChecked instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Mint for the account\n   * @param account Account to burn tokens from\n   * @param owner Owner of the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount amount to burn\n   */\n\n\n  static createBurnCheckedInstruction(programId, mint, account, owner, multiSigners, amount, decimals) {\n    const dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 15,\n      // BurnChecked instruction\n      amount: new u64(amount).toBuffer(),\n      decimals\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a SyncNative instruction\n   *\n   * @param programId SPL Token program account\n   * @param nativeAccount Account to sync lamports from\n   */\n\n\n  static createSyncNativeInstruction(programId, nativeAccount) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = buffer.Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 17 // SyncNative instruction\n\n    }, data);\n    let keys = [{\n      pubkey: nativeAccount,\n      isSigner: false,\n      isWritable: true\n    }];\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Get the address for the associated token account\n   *\n   * @param associatedProgramId SPL Associated Token program account\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param owner Owner of the new account\n   * @return Public key of the associated token account\n   */\n\n\n  static async getAssociatedTokenAddress(associatedProgramId, programId, mint, owner, allowOwnerOffCurve = false) {\n    if (!allowOwnerOffCurve && !_solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey.isOnCurve(owner.toBuffer())) {\n      throw new Error(`Owner cannot sign: ${owner.toString()}`);\n    }\n\n    return (await _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedProgramId))[0];\n  }\n  /**\n   * Construct the AssociatedTokenProgram instruction to create the associated\n   * token account\n   *\n   * @param associatedProgramId SPL Associated Token program account\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param associatedAccount New associated account\n   * @param owner Owner of the new account\n   * @param payer Payer of fees\n   */\n\n\n  static createAssociatedTokenAccountInstruction(associatedProgramId, programId, mint, associatedAccount, owner, payer) {\n    const data = buffer.Buffer.alloc(0);\n    let keys = [{\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: associatedAccount,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: owner,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: programId,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.TransactionInstruction({\n      keys,\n      programId: associatedProgramId,\n      data\n    });\n  }\n\n}\n\n\n//# sourceMappingURL=index.browser.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9zcGwtdG9rZW4vbGliL2luZGV4LmJyb3dzZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQzdDO0FBQ2dLOztBQUV2TDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxx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Q0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsdUJBQXVCLHFCQUFNLG1CQUFtQixxQkFBTTtBQUN0RDtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFj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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLFlBQVk7QUFDWjs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsWUFBWTtBQUNaOztBQUVBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUIsaURBQWlEO0FBQ2xFOztB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Q0E7O0FBRUEsNEVBQTRFLHdEQUFXO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxvRUFBb0Usd0RBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FLHdEQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUUsd0RBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUUsd0RBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUUsd0RBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUUsd0RBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsMEVBQTBFLHdEQUFXO0FBQ3JGO0FBQ0E7QUFDQTtB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxnQ0FBZ0Msc0RBQVM7QUFDekMsNENBQTRDLGlCQUFpQjtBQUM3RDs7QUFFQSxrQkFBa0Isc0RBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYywwREFBYTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLCtEQUFrQjtBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsbUVBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFNkc7QUFDN0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvc3BsLXRva2VuL2xpYi9pbmRleC5icm93c2VyLmVzbS5qcz9jNTk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IHsgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiBhcyBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uJDEsIFB1YmxpY0tleSwgS2V5cGFpciwgVHJhbnNhY3Rpb24sIFN5c3RlbVByb2dyYW0sIFNZU1ZBUl9SRU5UX1BVQktFWSwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5cbnZhciBidWZmZXIgPSB7fTtcblxudmFyIGJhc2U2NEpzID0ge307XG5cbmJhc2U2NEpzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuYmFzZTY0SnMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheTtcbmJhc2U2NEpzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5O1xuXG52YXIgbG9va3VwID0gW107XG52YXIgcmV2TG9va3VwID0gW107XG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzO1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKTtcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW47XG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KTtcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpO1xuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7XG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpO1xuXG4gIHZhciBjdXJCeXRlID0gMDtcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuO1xuXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRik7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpO1xuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgICk7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdO1xuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG52YXIgaWVlZTc1NCA9IHt9O1xuXG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuXG5pZWVlNzU0LnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbTtcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gLTc7XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDA7XG4gIHZhciBkID0gaXNMRSA/IC0xIDogMTtcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59O1xuXG5pZWVlNzU0LndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjO1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG5jb25zdCBiYXNlNjQgPSBiYXNlNjRKcztcbmNvbnN0IGllZWU3NTQkMSA9IGllZWU3NTQ7XG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsO1xuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjtcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXI7XG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmY7XG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEg7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKTtcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApO1xufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH07XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pO1xuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpO1xuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyOyAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpO1xuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKTtcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn07XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSk7XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufTtcblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufTtcbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7XG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpO1xuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbCk7XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NTtcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5Vmlldyk7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZjtcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpO1xuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pO1xuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbik7XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMDtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59O1xuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoO1xuICBsZXQgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpO1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIGxldCBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldO1xuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpO1xuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXJcbn07XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKTtcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dO1xuICBiW25dID0gYlttXTtcbiAgYlttXSA9IGk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7XG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnO1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTO1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpO1xuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnO1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKTtcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDtcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwO1xuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwO1xuICBlbmQgPj4+PSAwO1xuICB0aGlzU3RhcnQgPj4+PSAwO1xuICB0aGlzRW5kID4+Pj0gMDtcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDtcbiAgbGV0IHkgPSBlbmQgLSBzdGFydDtcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldO1xuICAgICAgeSA9IHRhcmdldENvcHlbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMDtcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGOyAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMTtcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpO1xuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBsZXQgaTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBvZmZzZXQgPSAwO1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwO1xuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmc7XG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICBjb25zdCByZXMgPSBbXTtcblxuICBsZXQgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbDtcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDE7XG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KTtcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJztcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcblxuICBsZXQgb3V0ID0gJyc7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXTtcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBsZXQgcmVzID0gJyc7XG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgc3RhcnQgPSB+fnN0YXJ0O1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW47XG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKTtcblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgbGV0IG11bCA9IDE7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF07XG4gIGxldCBtdWwgPSAxO1xuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsO1xuICB9XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKTtcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07XG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddO1xuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7XG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQ7XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjQ7XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSk7XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdO1xuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTtcbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpO1xuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdO1xuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0O1xuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pO1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdO1xuICBsZXQgbXVsID0gMTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIGxldCBpID0gYnl0ZUxlbmd0aDtcbiAgbGV0IG11bCA9IDE7XG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKTtcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07XG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddO1xuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7XG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpOyAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSk7XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpO1xuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTtcbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107XG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTtcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdO1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiBpZWVlNzU0JDEucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiBpZWVlNzU0JDEucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiBpZWVlNzU0JDEucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIGllZWU3NTQkMS5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIGxldCBtdWwgPSAxO1xuICBsZXQgaSA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIGxldCBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KTtcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpO1xuICBidWZbb2Zmc2V0KytdID0gbG87XG4gIGxvID0gbG8gPj4gODtcbiAgYnVmW29mZnNldCsrXSA9IGxvO1xuICBsbyA9IGxvID4+IDg7XG4gIGJ1ZltvZmZzZXQrK10gPSBsbztcbiAgbG8gPSBsbyA+PiA4O1xuICBidWZbb2Zmc2V0KytdID0gbG87XG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKTtcbiAgYnVmW29mZnNldCsrXSA9IGhpO1xuICBoaSA9IGhpID4+IDg7XG4gIGJ1ZltvZmZzZXQrK10gPSBoaTtcbiAgaGkgPSBoaSA+PiA4O1xuICBidWZbb2Zmc2V0KytdID0gaGk7XG4gIGhpID0gaGkgPj4gODtcbiAgYnVmW29mZnNldCsrXSA9IGhpO1xuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7XG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKTtcbiAgYnVmW29mZnNldCArIDddID0gbG87XG4gIGxvID0gbG8gPj4gODtcbiAgYnVmW29mZnNldCArIDZdID0gbG87XG4gIGxvID0gbG8gPj4gODtcbiAgYnVmW29mZnNldCArIDVdID0gbG87XG4gIGxvID0gbG8gPj4gODtcbiAgYnVmW29mZnNldCArIDRdID0gbG87XG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKTtcbiAgYnVmW29mZnNldCArIDNdID0gaGk7XG4gIGhpID0gaGkgPj4gODtcbiAgYnVmW29mZnNldCArIDJdID0gaGk7XG4gIGhpID0gaGkgPj4gODtcbiAgYnVmW29mZnNldCArIDFdID0gaGk7XG4gIGhpID0gaGkgPj4gODtcbiAgYnVmW29mZnNldF0gPSBoaTtcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgbGV0IGkgPSAwO1xuICBsZXQgbXVsID0gMTtcbiAgbGV0IHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICBsZXQgbXVsID0gMTtcbiAgbGV0IHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAxXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pO1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pO1xuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcbiAgfVxuICBpZWVlNzU0JDEud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTtcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgpO1xuICB9XG4gIGllZWU3NTQkMS53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0O1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIGxldCBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fTtcbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gO1xuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZTtcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfTtcbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpO1xuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpO1xuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmA7XG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXQ7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpO1xuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZCk7XG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbic7XG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YDtcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpO1xuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJyc7XG4gIGxldCBpID0gdmFsLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwO1xuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWA7XG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKTtcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnO1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKTtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF07XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKTtcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nO1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcbiAgbGV0IGNvZGVQb2ludDtcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuICBjb25zdCBieXRlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG87XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhpID0gYyA+PiA4O1xuICAgIGxvID0gYyAlIDI1NjtcbiAgICBieXRlQXJyYXkucHVzaChsbyk7XG4gICAgYnl0ZUFycmF5LnB1c2goaGkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTY7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKTtcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG59KGJ1ZmZlcikpO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG5cbnZhciBpbmhlcml0cztcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH07XG59XG52YXIgaW5oZXJpdHMkMSA9IGluaGVyaXRzO1xuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0JDEob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBfZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QkMS5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0JDEuc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0JDEuc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0JDEuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0JDEuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBpbnNwZWN0JDEgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSA7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZChvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufVxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIF9mdW5jdGlvbnNIYXZlTmFtZXM7XG5mdW5jdGlvbiBmdW5jdGlvbnNIYXZlTmFtZXMoKSB7XG4gIGlmICh0eXBlb2YgX2Z1bmN0aW9uc0hhdmVOYW1lcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gX2Z1bmN0aW9uc0hhdmVOYW1lcztcbiAgfVxuICByZXR1cm4gX2Z1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xuICB9KCkpO1xufVxuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoYnVmZmVyLmlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwkMS5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIG9rKTtcbn1cblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKCkpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufVxuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuaW5oZXJpdHMkMShBc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMoKSB8fCAhaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIGluc3BlY3QkMShzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBvayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5hc3NlcnQuZXF1YWwgPSBlcXVhbDtcbmZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBlcXVhbCk7XG59XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcbmFzc2VydC5ub3RFcXVhbCA9IG5vdEVxdWFsO1xuZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBub3RFcXVhbCk7XG4gIH1cbn1cblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcbmFzc2VydC5kZWVwRXF1YWwgPSBkZWVwRXF1YWw7XG5mdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgZGVlcEVxdWFsKTtcbiAgfVxufVxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGRlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGJ1ZmZlci5pc0J1ZmZlcihhY3R1YWwpICYmIGJ1ZmZlci5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoaXNEYXRlKGFjdHVhbCkgJiYgaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChhY3R1YWwpICYmIGlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGJ1ZmZlci5pc0J1ZmZlcihhY3R1YWwpICE9PSBidWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAoaXNQcmltaXRpdmUoYSkgfHwgaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5hc3NlcnQubm90RGVlcEVxdWFsID0gbm90RGVlcEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgbm90RGVlcEVxdWFsKTtcbiAgfVxufVxuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBzdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBzdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBub3RTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5hc3NlcnQudGhyb3dzID0gdGhyb3dzO1xuZnVuY3Rpb24gdGhyb3dzKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGRvZXNOb3RUaHJvdztcbmZ1bmN0aW9uIGRvZXNOb3RUaHJvdyhibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn1cblxuYXNzZXJ0LmlmRXJyb3IgPSBpZkVycm9yO1xuZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuXG52YXIgTGF5b3V0JDEgPSB7fTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXlvdXQgb2JqZWN0cy5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnRlZ2VyOyBhIG5lZ2F0aXZlIHZhbHVlIHNpZ25pZmllcyB0aGF0IHRoZVxuICogc3BhbiBpcyB7QGxpbmsgTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTGF5b3V0IHtcbiAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC5cbiAgICAgKlxuICAgICAqIFplcm8gd2lsbCBvbmx5IGFwcGVhciBpbiB7QGxpbmsgQ29uc3RhbnR9cyBhbmQgaW4ge0BsaW5rXG4gICAgICogU2VxdWVuY2V9cyB3aGVyZSB0aGUge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSBpcyB6ZXJvLlxuICAgICAqXG4gICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgc3BhbiBpcyB2YWx1ZS1zcGVjaWZpYywgYW5kXG4gICAgICogbXVzdCBiZSBvYnRhaW5lZCB1c2luZyB7QGxpbmsgTGF5b3V0I2dldFNwYW58Z2V0U3Bhbn0uICovXG4gICAgdGhpcy5zcGFuID0gc3BhbjtcblxuICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBsYXlvdXQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgKiBPYmplY3QuXG4gICAgICpcbiAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAqIGluc3RhbmNlcy4gIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBzcGFuIG9mIHRoZSB1bm5hbWVkIGxheW91dCB3aWxsXG4gICAgICogYmUgdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIH1cblxuICAvKiogRnVuY3Rpb24gdG8gY3JlYXRlIGFuIE9iamVjdCBpbnRvIHdoaWNoIGRlY29kZWQgcHJvcGVydGllcyB3aWxsXG4gICAqIGJlIHdyaXR0ZW4uXG4gICAqXG4gICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAqIGluc3RhbmNlcywgd2hpY2ggbWVhbnM6XG4gICAqICoge0BsaW5rIFN0cnVjdHVyZX1cbiAgICogKiB7QGxpbmsgVW5pb259XG4gICAqICoge0BsaW5rIFZhcmlhbnRMYXlvdXR9XG4gICAqICoge0BsaW5rIEJpdFN0cnVjdHVyZX1cbiAgICpcbiAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbGF5b3V0c1xuICAgKiB3aWxsIGJlIE9iamVjdCBpbnN0YW5jZXMuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgYmluZENvbnN0cnVjdG9yTGF5b3V0fS5cbiAgICovXG4gIG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGZyb20gYSBCdWZmZXIgaW50byBhbiBKYXZhU2NyaXB0IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYiAtIHRoZSBidWZmZXIgZnJvbSB3aGljaCBlbmNvZGVkIGRhdGEgaXMgcmVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBkYXRhXG4gICAqIHN0YXJ0cy4gIElmIGFic2VudCBhIHplcm8gb2Zmc2V0IGlzIGluZmVycmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7KE51bWJlcnxBcnJheXxPYmplY3QpfSAtIHRoZSB2YWx1ZSBvZiB0aGUgZGVjb2RlZCBkYXRhLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheW91dCBpcyBhYnN0cmFjdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIEphdmFTY3JpcHQgdmFsdWUgaW50byBhIEJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHsoTnVtYmVyfEFycmF5fE9iamVjdCl9IHNyYyAtIHRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkIGludG9cbiAgICogdGhlIGJ1ZmZlci4gIFRoZSB0eXBlIGFjY2VwdGVkIGRlcGVuZHMgb24gdGhlIChzdWItKXR5cGUgb2Yge0BsaW5rXG4gICAqIExheW91dH0uXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBiIC0gdGhlIGJ1ZmZlciBpbnRvIHdoaWNoIGVuY29kZWQgZGF0YSB3aWxsIGJlXG4gICAqIHdyaXR0ZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVuY29kZWQgZGF0YVxuICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGVuY29kZWQsIGluY2x1ZGluZyB0aGVcbiAgICogc3BhY2Ugc2tpcHBlZCBmb3IgaW50ZXJuYWwgcGFkZGluZywgYnV0IGV4Y2x1ZGluZyBkYXRhIHN1Y2ggYXNcbiAgICoge0BsaW5rIFNlcXVlbmNlI2NvdW50fGxlbmd0aHN9IHdoZW4gc3RvcmVkIHtAbGlua1xuICAgKiBFeHRlcm5hbExheW91dHxleHRlcm5hbGx5fS4gIFRoaXMgaXMgdGhlIGFkanVzdG1lbnQgdG8gYG9mZnNldGBcbiAgICogcHJvZHVjaW5nIHRoZSBvZmZzZXQgd2hlcmUgZGF0YSBmb3IgdGhlIG5leHQgbGF5b3V0IHdvdWxkIGJlXG4gICAqIHdyaXR0ZW4uXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMYXlvdXQgaXMgYWJzdHJhY3QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNwYW4gb2YgYSBzcGVjaWZpYyBpbnN0YW5jZSBvZiBhIGxheW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGIgLSB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMgYW4gZW5jb2RlZCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBpbnN0YW5jZVxuICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgY292ZXJlZCBieSB0aGUgbGF5b3V0XG4gICAqIGluc3RhbmNlLiAgSWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0aGVcbiAgICogZGVmaW5pdGlvbi10aW1lIGNvbnN0YW50IHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSB3aWxsIGJlXG4gICAqIHJldHVybmVkLlxuICAgKlxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSAtIGlmIHRoZSBsZW5ndGggb2YgdGhlIHZhbHVlIGNhbm5vdCBiZVxuICAgKiBkZXRlcm1pbmVkLlxuICAgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA+IHRoaXMuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGFuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxpY2F0ZSB0aGUgbGF5b3V0IHVzaW5nIGEgbmV3IHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBnZXQgYSBzdHJ1Y3R1cmFsbHktZXF1aXZhbGVudCBsYXlvdXRcbiAgICogd2l0aCBhIGRpZmZlcmVudCBuYW1lIHNpbmNlIGFsbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZXMgYXJlXG4gICAqIGltbXV0YWJsZS5cbiAgICpcbiAgICogKipOT1RFKiogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gIEFsbCBmaWVsZHMgZXhjZXB0IHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGFyZSBzdHJpY3RseSBlcXVhbCB0byB0aGUgb3JpZ2luIGxheW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHZhbHVlIGZvciB7QGxpbmtcbiAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSBpbiB0aGUgcmVwbGljYS5cbiAgICpcbiAgICogQHJldHVybnMge0xheW91dH0gLSB0aGUgY29weSB3aXRoIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gICAqIHNldCB0byBgcHJvcGVydHlgLlxuICAgKi9cbiAgcmVwbGljYXRlKHByb3BlcnR5KSB7XG4gICAgY29uc3QgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICBPYmplY3QuYXNzaWduKHJ2LCB0aGlzKTtcbiAgICBydi5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gb2JqZWN0IGZyb20gbGF5b3V0IHByb3BlcnRpZXMgYW5kIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICpcbiAgICogKipOT1RFKiogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIGlmIGludm9rZWQgb24gYSBsYXlvdXRcbiAgICogdGhhdCBkb2VzIG5vdCByZXR1cm4gaXRzIHZhbHVlIGFzIGFuIE9iamVjdC4gIE9iamVjdHMgYXJlXG4gICAqIHJldHVybmVkIGZvciB0aGluZ3MgdGhhdCBhcmUgYSB7QGxpbmsgU3RydWN0dXJlfSwgd2hpY2ggaW5jbHVkZXNcbiAgICoge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBpZiB0aGV5IGFyZSBzdHJ1Y3R1cmVzLCBhbmRcbiAgICogZXhjbHVkZXMge0BsaW5rIFVuaW9ufXMuICBJZiB5b3Ugd2FudCB0aGlzIGZlYXR1cmUgZm9yIGEgdW5pb25cbiAgICogeW91IG11c3QgdXNlIHtAbGluayBVbmlvbi5nZXRWYXJpYW50fGdldFZhcmlhbnR9IHRvIHNlbGVjdCB0aGVcbiAgICogZGVzaXJlZCBsYXlvdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIGFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gICAqIGRlZmF1bHQgb3JkZXIgZm9yIHByb3BlcnRpZXMuICBBcyB3aXRoIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX1cbiAgICogbGF5b3V0IGVsZW1lbnRzIHRoYXQgaGF2ZSBubyBwcm9wZXJ0eSBuYW1lIGFyZSBza2lwcGVkIHdoZW5cbiAgICogaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IHZhbHVlcy4gIE9ubHkgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGFyZVxuICAgKiBhc3NpZ25lZDsgYXJndW1lbnRzIGFyZSBub3QgYXNzaWduZWQgdG8gcHJvcGVydGllcyBvZiBjb250YWluZWRcbiAgICogbGF5b3V0cy4gIEFueSB1bnVzZWQgdmFsdWVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fHVuZGVmaW5lZCl9XG4gICAqL1xuICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuTGF5b3V0JDEuTGF5b3V0ID0gTGF5b3V0O1xuXG4vKiBQcm92aWRlIHRleHQgdGhhdCBjYXJyaWVzIGEgbmFtZSAoc3VjaCBhcyBmb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAqIGJlIHRocm93aW5nIGFuIGVycm9yKSBhbm5vdGF0ZWQgd2l0aCB0aGUgcHJvcGVydHkgb2YgYSBnaXZlbiBsYXlvdXRcbiAqIChzdWNoIGFzIG9uZSBmb3Igd2hpY2ggdGhlIHZhbHVlIHdhcyB1bmFjY2VwdGFibGUpLlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIG5hbWVXaXRoUHJvcGVydHkobmFtZSwgbG8pIHtcbiAgaWYgKGxvLnByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5hbWUgKyAnWycgKyBsby5wcm9wZXJ0eSArICddJztcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbkxheW91dCQxLm5hbWVXaXRoUHJvcGVydHkgPSBuYW1lV2l0aFByb3BlcnR5O1xuXG4vKipcbiAqIEF1Z21lbnQgYSBjbGFzcyBzbyB0aGF0IGluc3RhbmNlcyBjYW4gYmUgZW5jb2RlZC9kZWNvZGVkIHVzaW5nIGFcbiAqIGdpdmVuIGxheW91dC5cbiAqXG4gKiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gY291cGxlcyBgQ2xhc3NgIHdpdGggYGxheW91dGAgaW4gc2V2ZXJhbCB3YXlzOlxuICpcbiAqICogYENsYXNzLmxheW91dF9gIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIHByb3BlcnR5IGVxdWFsIHRvIGBsYXlvdXRgO1xuICogKiBgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbFxuICogICAgdG8gYENsYXNzYDtcbiAqICogVGhlIHtAbGluayBMYXlvdXQjbWFrZURlc3RpbmF0aW9uT2JqZWN0fG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpfVxuICogICBwcm9wZXJ0eSBvZiBgbGF5b3V0YCBpcyBzZXQgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBgbmV3XG4gKiAgIENsYXNzKClgO1xuICogKiBgQ2xhc3MuZGVjb2RlKGIsIG9mZnNldClgIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIGZ1bmN0aW9uIHRoYXRcbiAqICAgZGVsZWdhdGVzIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfGxheW91dC5kZWNvZGV9LiAgVGhlXG4gKiAgIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZSBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQuXG4gKiAqIGBDbGFzcy5wcm90b3R5cGUuZW5jb2RlKGIsIG9mZnNldClgIHByb3ZpZGVzIGFuIGluc3RhbmNlIG1lbWJlclxuICogICBmdW5jdGlvbiB0aGF0IGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2VuY29kZXxsYXlvdXQuZW5jb2RlfVxuICogICB3aXRoIGBzcmNgIHNldCB0byBgdGhpc2AuICBUaGUgc3ludGhlc2l6ZWQgZnVuY3Rpb24gbWF5IGJlXG4gKiAgIGNhcHR1cmVkIGFuZCBleHRlbmRlZCwgYnV0IHdoZW4gdGhlIGV4dGVuc2lvbiBpcyBpbnZva2VkIGB0aGlzYFxuICogICBtdXN0IGJlIGV4cGxpY2l0bHkgYm91bmQgdG8gdGhlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Y2xhc3N9IENsYXNzIC0gYSBKYXZhU2NyaXB0IGNsYXNzIHdpdGggYSBudWxsYXJ5XG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gdGhlIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIHVzZWQgdG8gZW5jb2RlXG4gKiBpbnN0YW5jZXMgb2YgYENsYXNzYC5cbiAqL1xuZnVuY3Rpb24gYmluZENvbnN0cnVjdG9yTGF5b3V0KENsYXNzLCBsYXlvdXQpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBDbGFzcykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NsYXNzIG11c3QgYmUgY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAoQ2xhc3MuaGFzT3duUHJvcGVydHkoJ2xheW91dF8nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3MgaXMgYWxyZWFkeSBib3VuZCB0byBhIGxheW91dCcpO1xuICB9XG4gIGlmICghKGxheW91dCAmJiAobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICB9XG4gIGlmIChsYXlvdXQuaGFzT3duUHJvcGVydHkoJ2JvdW5kQ29uc3RydWN0b3JfJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheW91dCBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgY29uc3RydWN0b3InKTtcbiAgfVxuICBDbGFzcy5sYXlvdXRfID0gbGF5b3V0O1xuICBsYXlvdXQuYm91bmRDb25zdHJ1Y3Rvcl8gPSBDbGFzcztcbiAgbGF5b3V0Lm1ha2VEZXN0aW5hdGlvbk9iamVjdCA9ICgoKSA9PiBuZXcgQ2xhc3MoKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsICdlbmNvZGUnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGIsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGxheW91dC5lbmNvZGUodGhpcywgYiwgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLCAnZGVjb2RlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihiLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBsYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgfSk7XG59XG5MYXlvdXQkMS5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSBiaW5kQ29uc3RydWN0b3JMYXlvdXQ7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgYmVoYXZlcyBsaWtlIGEgbGF5b3V0IGJ1dCBkb2VzIG5vdCBjb25zdW1lIHNwYWNlXG4gKiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgbGF5b3V0LlxuICpcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gb2J0YWluIG1ldGFkYXRhIGFib3V0IGEgbWVtYmVyLCBzdWNoIGFzIGFcbiAqIHtAbGluayBPZmZzZXRMYXlvdXR9IHRoYXQgY2FuIHByb3ZpZGUgZGF0YSBhYm91dCBhIHtAbGlua1xuICogTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWMgc3Bhbn0uXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnR9IG9yIG90aGVyIHtAbGluayBMYXlvdXR9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBFeHRlcm5hbExheW91dCBleHRlbmRzIExheW91dCB7XG4gIC8qKlxuICAgKiBSZXR1cm4gYHRydWVgIGlmZiB0aGUgZXh0ZXJuYWwgbGF5b3V0IGRlY29kZXMgdG8gYW4gdW5zaWduZWRcbiAgICogaW50ZWdlciBsYXlvdXQuXG4gICAqXG4gICAqIEluIHRoYXQgY2FzZSBpdCBjYW4gYmUgdXNlZCBhcyB0aGUgc291cmNlIG9mIHtAbGlua1xuICAgKiBTZXF1ZW5jZSNjb3VudHxTZXF1ZW5jZSBjb3VudHN9LCB7QGxpbmsgQmxvYiNsZW5ndGh8QmxvYiBsZW5ndGhzfSxcbiAgICogb3IgYXMge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8ZXh0ZXJuYWwgdW5pb25cbiAgICogZGlzY3JpbWluYXRvcnN9LlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGlzQ291bnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlcm5hbExheW91dCBpcyBhYnN0cmFjdCcpO1xuICB9XG59XG5cbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IGRldGVybWluZXMgaXRzIHtAbGlua1xuICogTGF5b3V0I2RlY29kZXx2YWx1ZX0gYmFzZWQgb24gb2Zmc2V0IGludG8gYW5kIGxlbmd0aCBvZiB0aGUgYnVmZmVyXG4gKiBvbiB3aGljaCBpdCBpcyBpbnZva2VkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZ3JlZWR5fGdyZWVkeX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2VsZW1lbnRTcGFuXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEdyZWVkeUNvdW50I2VsZW1lbnRTcGFufGVsZW1lbnRTcGFufS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtFeHRlcm5hbExheW91dH1cbiAqL1xuY2xhc3MgR3JlZWR5Q291bnQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IGVsZW1lbnRTcGFuKSB7XG4gICAgICBlbGVtZW50U3BhbiA9IDE7XG4gICAgfVxuICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoZWxlbWVudFNwYW4pKSB8fCAoMCA+PSBlbGVtZW50U3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRTcGFuIG11c3QgYmUgYSAocG9zaXRpdmUpIGludGVnZXInKTtcbiAgICB9XG4gICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gIFRoZSB2YWx1ZVxuICAgICAqIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiAgSWYgbm90IHByb3ZpZGVkLCB0aGUgdmFsdWUgd2lsbCBiZVxuICAgICAqIDEuICovXG4gICAgdGhpcy5lbGVtZW50U3BhbiA9IGVsZW1lbnRTcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpc0NvdW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCByZW0gPSBiLmxlbmd0aCAtIG9mZnNldDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihyZW0gLyB0aGlzLmVsZW1lbnRTcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc3VwcG9ydHMgYWNjZXNzaW5nIGEge0BsaW5rIExheW91dH1cbiAqIGF0IGEgZml4ZWQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIGFub3RoZXIgTGF5b3V0LiAgVGhlIG9mZnNldCBtYXlcbiAqIGJlIGJlZm9yZSwgd2l0aGluLCBvciBhZnRlciB0aGUgYmFzZSBsYXlvdXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5vZmZzZXR8b2Zmc2V0fVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjbGF5b3V0fGxheW91dH0sIG1vZHVsbyBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIEluaXRpYWxpemVzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I29mZnNldHxvZmZzZXR9LiAgRGVmYXVsdHMgdG8gemVyby5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIE9wdGlvbmFsIG5ldyBwcm9wZXJ0eSBuYW1lIGZvciBhXG4gKiB7QGxpbmsgTGF5b3V0I3JlcGxpY2F0ZXwgcmVwbGljYX0gb2YgYGxheW91dGAgdG8gYmUgdXNlZCBhcyB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fS4gIElmIG5vdCBwcm92aWRlZCB0aGUgYGxheW91dGAgaXMgdXNlZFxuICogdW5jaGFuZ2VkLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBPZmZzZXRMYXlvdXQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkge1xuICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIob2Zmc2V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgaW50ZWdlciBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBzdXBlcihsYXlvdXQuc3BhbiwgcHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgc3Vib3JkaW5hdGVkIGxheW91dC4gKi9cbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcblxuICAgIC8qKiBUaGUgbG9jYXRpb24gb2Yge0BsaW5rIE9mZnNldExheW91dCNsYXlvdXR9IHJlbGF0aXZlIHRvIHRoZVxuICAgICAqIHN0YXJ0IG9mIGFub3RoZXIgbGF5b3V0LlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIG1heSBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgYnV0IGFuIGVycm9yIHdpbGwgdGhyb3duXG4gICAgICogaWYgYXQgdGhlIHBvaW50IG9mIHVzZSBpdCBnb2VzIG91dHNpZGUgdGhlIHNwYW4gb2YgdGhlIEJ1ZmZlclxuICAgICAqIGJlaW5nIGFjY2Vzc2VkLiAgKi9cbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaXNDb3VudCgpIHtcbiAgICByZXR1cm4gKCh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAodGhpcy5sYXlvdXQgaW5zdGFuY2VvZiBVSW50QkUpKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCArIHRoaXMub2Zmc2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8dTh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUxNnx1MTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8dTI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MzJ8dTMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwfHU0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTQ4fHU0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZFVJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZVVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICByZXR1cm4gdGhpcy5zcGFuO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51OGJlfHU4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQudTE2YmV8dTE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjRiZXx1MjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXx1MzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51NDBiZXx1NDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OGJlfHU0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKCBzcGFuLCBwcm9wZXJ0eSk7XG4gICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkVUludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlVUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fHM4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMTZ8czE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fHMyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczMyfHMzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MHxzNDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnM0OHxzNDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlSW50TEUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczhiZXxzOGJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnMxNmJlfHMxNmJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0YmV8czI0YmV9LFxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8czMyYmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczQwYmV8czQwYmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDhiZXxzNDhiZX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRJbnRCRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cbn1cblxuY29uc3QgVjJFMzIgPSBNYXRoLnBvdygyLCAzMik7XG5cbi8qIFRydWUgbW9kdWx1cyBoaWdoIGFuZCBsb3cgMzItYml0IHdvcmRzLCB3aGVyZSBsb3cgd29yZCBpcyBhbHdheXNcbiAqIG5vbi1uZWdhdGl2ZS4gKi9cbmZ1bmN0aW9uIGRpdm1vZEludDY0KHNyYykge1xuICBjb25zdCBoaTMyID0gTWF0aC5mbG9vcihzcmMgLyBWMkUzMik7XG4gIGNvbnN0IGxvMzIgPSBzcmMgLSAoaGkzMiAqIFYyRTMyKTtcbiAgcmV0dXJuIHtoaTMyLCBsbzMyfTtcbn1cbi8qIFJlY29uc3RydWN0IE51bWJlciBmcm9tIHF1b3RpZW50IGFuZCBub24tbmVnYXRpdmUgcmVtYWluZGVyICovXG5mdW5jdGlvbiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMikge1xuICByZXR1cm4gaGkzMiAqIFYyRTMyICsgbG8zMjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm51NjR8bnU2NH1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhclVJbnQ2NCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBsbzMyID0gYi5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICBjb25zdCBoaTMyID0gYi5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmhpMzIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0YmV8bnU2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgaGkzMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgIGIud3JpdGVVSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgIGIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICByZXR1cm4gODtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NHxuczY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgY29uc3QgaGkzMiA9IGIucmVhZEludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIDg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjRiZXxuczY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IGhpMzIgPSBiLnJlYWRJbnQzMkJFKG9mZnNldCk7XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgIGIud3JpdGVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMnxmMzJ9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBGbG9hdCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkRmxvYXRMRShvZmZzZXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGIud3JpdGVGbG9hdExFKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gNDtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJiZXxmMzJiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEZsb2F0QkUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlRmxvYXRCRShzcmMsIG9mZnNldCk7XG4gICAgcmV0dXJuIDQ7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0fGY2NH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIERvdWJsZSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkRG91YmxlTEUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlRG91YmxlTEUoc3JjLCBvZmZzZXQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmY2NGJlfGY2NGJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlQkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZERvdWJsZUJFKG9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZURvdWJsZUJFKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gODtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYSBzcGVjaWZpYyBsYXlvdXQgYXMgYW4gQXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8c2VxfVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBlbGVtZW50TGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjZWxlbWVudExheW91dHxlbGVtZW50TGF5b3V0fS5cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBjb3VudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFNlcXVlbmNlI2NvdW50fGNvdW50fS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZVxuICogaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU2VxdWVuY2UgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpIHtcbiAgICBpZiAoIShlbGVtZW50TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudExheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmICghKCgoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgY291bnQuaXNDb3VudCgpKVxuICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGNvdW50KSAmJiAoMCA8PSBjb3VudCkpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY291bnQgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSAtMTtcbiAgICBpZiAoKCEoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpXG4gICAgICAgICYmICgwIDwgZWxlbWVudExheW91dC5zcGFuKSkge1xuICAgICAgc3BhbiA9IGNvdW50ICogZWxlbWVudExheW91dC5zcGFuO1xuICAgIH1cblxuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gKi9cbiAgICB0aGlzLmVsZW1lbnRMYXlvdXQgPSBlbGVtZW50TGF5b3V0O1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGJlIGVpdGhlciBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mXG4gICAgICoge0BsaW5rIEV4dGVybmFsTGF5b3V0fSBmb3Igd2hpY2gge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9IGlzIGB0cnVlYC4gKi9cbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBzcGFuID0gMDtcbiAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICBpZiAoMCA8IHRoaXMuZWxlbWVudExheW91dC5zcGFuKSB7XG4gICAgICBzcGFuID0gY291bnQgKiB0aGlzLmVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICB3aGlsZSAoaWR4IDwgY291bnQpIHtcbiAgICAgICAgc3BhbiArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgKytpZHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBydiA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICBydi5wdXNoKHRoaXMuZWxlbWVudExheW91dC5kZWNvZGUoYiwgb2Zmc2V0KSk7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbiAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU2VxdWVuY2V9LlxuICAgKlxuICAgKiAqKk5PVEUqKiBJZiBgc3JjYCBpcyBzaG9ydGVyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGVuXG4gICAqIHRoZSB1bnVzZWQgc3BhY2UgaW4gdGhlIGJ1ZmZlciBpcyBsZWZ0IHVuY2hhbmdlZC4gIElmIGBzcmNgIGlzXG4gICAqIGxvbmdlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlIHVubmVlZGVkIGVsZW1lbnRzIGFyZVxuICAgKiBpZ25vcmVkLlxuICAgKlxuICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgZWxvID0gdGhpcy5lbGVtZW50TGF5b3V0O1xuICAgIGNvbnN0IHNwYW4gPSBzcmMucmVkdWNlKChzcGFuLCB2KSA9PiB7XG4gICAgICByZXR1cm4gc3BhbiArIGVsby5lbmNvZGUodiwgYiwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgfSwgMCk7XG4gICAgaWYgKHRoaXMuY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgdGhpcy5jb3VudC5lbmNvZGUoc3JjLmxlbmd0aCwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGFyYml0cmFyeSBsYXlvdXQgZWxlbWVudHMgYXMgYW5cbiAqIE9iamVjdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxzdHJ1Y3R9XG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgc3RydWN0dXJlIGlzIHZhcmlhYmxlXG4gKiBpZiBhbnkgbGF5b3V0IGluIHtAbGluayBTdHJ1Y3R1cmUjZmllbGRzfGZpZWxkc30gaGFzIGEgdmFyaWFibGVcbiAqIHNwYW4uICBXaGVuIHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kaW5nfSB3ZSBtdXN0IGhhdmUgYSB2YWx1ZSBmb3JcbiAqIGFsbCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBvciB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIGZpZ3VyZSBvdXRcbiAqIGhvdyBtdWNoIHNwYWNlIHRvIHVzZSBmb3Igc3RvcmFnZS4gIFdlIGNhbiBvbmx5IGlkZW50aWZ5IHRoZSB2YWx1ZVxuICogZm9yIGEgZmllbGQgd2hlbiBpdCBoYXMgYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIEFzXG4gKiBzdWNoLCBhbHRob3VnaCBhIHN0cnVjdHVyZSBtYXkgY29udGFpbiBib3RoIHVubmFtZWQgZmllbGRzIGFuZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkcywgaXQgY2Fubm90IGNvbnRhaW4gYW4gdW5uYW1lZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0W119IGZpZWxkcyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfS4gIEFuIGVycm9yIGlzIHJhaXNlZCBpZiB0aGlzIGNvbnRhaW5zIGFcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZCBmb3Igd2hpY2ggYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fVxuICogaXMgbm90IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlY29kZVByZWZpeGVzXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNkZWNvZGVQcmVmaXhlc3xwcm9wZXJ0eX0uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gaWYgYGZpZWxkc2AgY29udGFpbnMgYW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGhcbiAqIGxheW91dC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpIHtcbiAgICBpZiAoIShBcnJheS5pc0FycmF5KGZpZWxkcylcbiAgICAgICAgICAmJiBmaWVsZHMucmVkdWNlKChhY2MsIHYpID0+IGFjYyAmJiAodiBpbnN0YW5jZW9mIExheW91dCksIHRydWUpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmllbGRzIG11c3QgYmUgYXJyYXkgb2YgTGF5b3V0IGluc3RhbmNlcycpO1xuICAgIH1cbiAgICBpZiAoKCdib29sZWFuJyA9PT0gdHlwZW9mIHByb3BlcnR5KVxuICAgICAgICAmJiAodW5kZWZpbmVkID09PSBkZWNvZGVQcmVmaXhlcykpIHtcbiAgICAgIGRlY29kZVByZWZpeGVzID0gcHJvcGVydHk7XG4gICAgICBwcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKiBWZXJpZnkgYWJzZW5jZSBvZiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMuICovXG4gICAgZm9yIChjb25zdCBmZCBvZiBmaWVsZHMpIHtcbiAgICAgIGlmICgoMCA+IGZkLnNwYW4pXG4gICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZmQucHJvcGVydHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGRzIGNhbm5vdCBjb250YWluIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGxheW91dCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzcGFuID0gLTE7XG4gICAgdHJ5IHtcbiAgICAgIHNwYW4gPSBmaWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4gc3BhbiArIGZkLmdldFNwYW4oKSwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBMYXlvdXR9IHZhbHVlcyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAqIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIFRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIG5lZWQgbm90IGJlIHRoZSBzYW1lIHR5cGUsIGFuZCBtYXkgYmVcbiAgICAgKiBlaXRoZXIgc2NhbGFyIG9yIGFnZ3JlZ2F0ZSBsYXlvdXRzLiAgSWYgYSBtZW1iZXIgbGF5b3V0IGxlYXZlc1xuICAgICAqIGl0cyB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB1bmRlZmluZWQgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgKiB3aWxsIG5vdCBiZSBtdXRhdGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge0xheW91dFtdfSAqL1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuXG4gICAgLyoqIENvbnRyb2wgYmVoYXZpb3Igb2Yge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlKCl9IGdpdmVuIHNob3J0XG4gICAgICogYnVmZmVycy5cbiAgICAgKlxuICAgICAqIEluIHNvbWUgc2l0dWF0aW9ucyBhIHN0cnVjdHVyZSBtYW55IGJlIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbFxuICAgICAqIGZpZWxkcyBvdmVyIHRpbWUsIHdpdGggb2xkZXIgaW5zdGFsbGF0aW9ucyBwcm92aWRpbmcgb25seSBhXG4gICAgICogcHJlZml4IG9mIHRoZSBmdWxsIHN0cnVjdHVyZS4gIElmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgXG4gICAgICogZGVjb2Rpbmcgd2lsbCBhY2NlcHQgdGhvc2UgYnVmZmVycyBhbmQgbGVhdmUgc3Vic2VxdWVudCBmaWVsZHNcbiAgICAgKiB1bmRlZmluZWQsIGFzIGxvbmcgYXMgdGhlIGJ1ZmZlciBlbmRzIGF0IGEgZmllbGQgYm91bmRhcnkuXG4gICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC4gKi9cbiAgICB0aGlzLmRlY29kZVByZWZpeGVzID0gISFkZWNvZGVQcmVmaXhlcztcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSAwO1xuICAgIHRyeSB7XG4gICAgICBzcGFuID0gdGhpcy5maWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4ge1xuICAgICAgICBjb25zdCBmc3AgPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBmc3A7XG4gICAgICAgIHJldHVybiBzcGFuICsgZnNwO1xuICAgICAgfSwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSBmZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICBpZiAodGhpcy5kZWNvZGVQcmVmaXhlc1xuICAgICAgICAgICYmIChiLmxlbmd0aCA9PT0gb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTdHJ1Y3R1cmV9LlxuICAgKlxuICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGlzXG4gICAqIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE9mZnNldCA9IG9mZnNldDtcbiAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgbGV0IGxhc3RXcm90ZSA9IDA7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgbGV0IHNwYW4gPSBmZC5zcGFuO1xuICAgICAgbGFzdFdyb3RlID0gKDAgPCBzcGFuKSA/IHNwYW4gOiAwO1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgIGxhc3RXcm90ZSA9IGZkLmVuY29kZShmdiwgYiwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIC8qIFJlYWQgdGhlIGFzLWVuY29kZWQgc3Bhbiwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IHRoZVxuICAgICAgICAgICAgICogc2FtZSBhcyB3aGF0IHdlIHdyb3RlLiAqL1xuICAgICAgICAgICAgc3BhbiA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgKz0gc3BhbjtcbiAgICB9XG4gICAgLyogVXNlIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSBpbnN0ZWFkIG9mIG9mZnNldCBiZWNhdXNlIHRoZSBsYXN0XG4gICAgICogaXRlbSBtYXkgaGF2ZSBoYWQgYSBkeW5hbWljIGxlbmd0aCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlXG4gICAgICogdGhlIHBhZGRpbmcgYmV0d2VlbiBpdCBhbmQgdGhlIGVuZCBvZiB0aGUgc3BhY2UgcmVzZXJ2ZWQgZm9yXG4gICAgICogaXQuICovXG4gICAgcmV0dXJuIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSAtIGZpcnN0T2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKCh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KVxuICAgICAgICAgICYmICgwIDwgdmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSB2YWx1ZXMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjY2VzcyB0byB0aGUgbGF5b3V0IG9mIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtMYXlvdXR9IC0gdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAqL1xuICBsYXlvdXRGb3IocHJvcGVydHkpIHtcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb2Zmc2V0IG9mIGEgc3RydWN0dXJlIG1lbWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgb2Zmc2V0IGluIGJ5dGVzIHRvIHRoZSBzdGFydCBvZiBgcHJvcGVydHlgXG4gICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLCBvciB1bmRlZmluZWQgaWYgYHByb3BlcnR5YCBpcyBub3QgYSBmaWVsZFxuICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZS4gIElmIHRoZSBwcm9wZXJ0eSBpcyBhIG1lbWJlciBidXQgZm9sbG93cyBhXG4gICAqIHZhcmlhYmxlLWxlbmd0aCBzdHJ1Y3R1cmUgbWVtYmVyIGEgbmVnYXRpdmUgbnVtYmVyIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqL1xuICBvZmZzZXRPZihwcm9wZXJ0eSkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAoMCA+IGZkLnNwYW4pIHtcbiAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKDAgPD0gb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCArPSBmZC5zcGFuO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IEFQSSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBVbmlvbkRpc2NyaW1pbmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIC8qKiBUaGUge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdG8gYmUgdXNlZCB3aGVuIHRoZVxuICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgcmVmZXJlbmNlZCBpbiBpc29sYXRpb24gKGdlbmVyYWxseSB3aGVuIHtAbGlua1xuICAgICAqIFVuaW9uI2RlY29kZXxVbmlvbiBkZWNvZGV9IGNhbm5vdCBkZWxlZ2F0ZSB0byBhIHNwZWNpZmljXG4gICAgICogdmFyaWFudCkuICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICB9XG5cbiAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZGVjb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAqXG4gICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCByZWZlcmVuY2UgdGhlIGJ1ZmZlciBpZlxuICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICBkZWNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgfVxuXG4gIC8qKiBBbmFsb2cgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8TGF5b3V0IGVuY29kZX0gZm9yIHVuaW9uIGRpc2NyaW1pbmF0b3JzLlxuICAgKlxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3Qgc3RvcmUgdGhlIHZhbHVlIGlmXG4gICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgbWFpbnRhaW5lZCB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICBlbmNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvciBBUEl9IGZvciB7QGxpbmsgVW5pb259IHVzaW5nIGFuXG4gKiB1bnNpZ25lZCBpbnRlZ3JhbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSBsb2NhdGVkIGVpdGhlciBpbnNpZGUgb3JcbiAqIG91dHNpZGUgdGhlIHVuaW9uLlxuICpcbiAqIEBwYXJhbSB7RXh0ZXJuYWxMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAgTXVzdCBzYXRpc2Z5IHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LCBzdXBlcnNlZGluZyB0aGUgcHJvcGVydHlcbiAqIGZyb20gYGxheW91dGAsIGJ1dCBkZWZhdWx0aW5nIHRvIGB2YXJpYW50YCBpZiBuZWl0aGVyIGBwcm9wZXJ0eWBcbiAqIG5vciBsYXlvdXQgcHJvdmlkZSBhIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQGF1Z21lbnRzIHtVbmlvbkRpc2NyaW1pbmF0b3J9XG4gKi9cbmNsYXNzIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciBleHRlbmRzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCwgcHJvcGVydHkpIHtcbiAgICBpZiAoISgobGF5b3V0IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgJiYgbGF5b3V0LmlzQ291bnQoKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICB9XG5cbiAgICBzdXBlcihwcm9wZXJ0eSB8fCBsYXlvdXQucHJvcGVydHkgfHwgJ3ZhcmlhbnQnKTtcblxuICAgIC8qKiBUaGUge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB1c2VkIHRvIGFjY2VzcyB0aGUgZGlzY3JpbWluYXRvclxuICAgICAqIHZhbHVlLiAqL1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB9XG5cbiAgLyoqIERlbGVnYXRlIGRlY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogRGVsZWdhdGUgZW5jb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYW55IG51bWJlciBvZiBzcGFuLWNvbXBhdGlibGUgbGF5b3V0cy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufHVuaW9ufVxuICpcbiAqIElmIHRoZSB1bmlvbiBoYXMgYSB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gdGhhdFxuICogbGF5b3V0IG11c3QgaGF2ZSBhIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGUgc3BhblxuICogb2YgYSBmaXhlZC1zcGFuIHVuaW9uIGluY2x1ZGVzIGl0cyB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaWYgdGhlIHZhcmlhbnQgaXMgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBvZiB0aGUgdW5pb259LCBwbHVzIHRoZSBzcGFuXG4gKiBvZiBpdHMge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LlxuICpcbiAqIElmIHRoZSB1bmlvbiBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBsYXlvdXQgdGhlbiB0aGUgZW5jb2RlZCBzcGFuXG4gKiBvZiB0aGUgdW5pb24gZGVwZW5kcyBvbiB0aGUgZW5jb2RlZCBzcGFuIG9mIGl0cyB2YXJpYW50ICh3aGljaCBtYXlcbiAqIGJlIGZpeGVkIG9yIHZhcmlhYmxlKS5cbiAqXG4gKiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8VmFyaWFudCBsYXlvdXR9cyBhcmUgYWRkZWQgdGhyb3VnaFxuICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uICBJZiB0aGUgdW5pb24gaGFzIGEgZGVmYXVsdFxuICogbGF5b3V0LCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dFxuICogY29udGFpbmVkIGJ5IHRoZSB2YXJpYW50fSBtdXN0IG5vdCBleGNlZWQgdGhlIHNwYW4gb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gKG1pbnVzIHRoZSBzcGFuIG9mIGEge0BsaW5rXG4gKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnxwcmVmaXggZGlzcmltaW5hdG9yfSwgaWYgdXNlZCkuICBUaGVcbiAqIHNwYW4gb2YgdGhlIHZhcmlhbnQgd2lsbCBlcXVhbCB0aGUgc3BhbiBvZiB0aGUgdW5pb24gaXRzZWxmLlxuICpcbiAqIFRoZSB2YXJpYW50IGZvciBhIGJ1ZmZlciBjYW4gb25seSBiZSBpZGVudGlmaWVkIGZyb20gdGhlIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0gKGluIHRoZSBjYXNlIG9mIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9KSwgb3IgYnkgdXNpbmcge0BsaW5rXG4gKiBVbmlvbiNnZXRWYXJpYW50fGdldFZhcmlhbnR9IGFuZCBleGFtaW5pbmcgdGhlIHJlc3VsdGluZyB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlLlxuICpcbiAqIEEgdmFyaWFudCBjb21wYXRpYmxlIHdpdGggYSBKYXZhU2NyaXB0IG9iamVjdCBjYW4gYmUgaWRlbnRpZmllZFxuICogdXNpbmcge0BsaW5rIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHsoVW5pb25EaXNjcmltaW5hdG9yfEV4dGVybmFsTGF5b3V0fExheW91dCl9IGRpc2NyIC0gSG93IHRvXG4gKiBpZGVudGlmeSB0aGUgbGF5b3V0IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB1bmlvbiBjb250ZW50cy4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0sIGFuXG4gKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LCBvciB7QGxpbmsgVUludH0gKG9yIHtAbGlua1xuICogVUludEJFfSkuICBXaGVuIGEgbm9uLWV4dGVybmFsIGxheW91dCBlbGVtZW50IGlzIHBhc3NlZCB0aGUgbGF5b3V0XG4gKiBhcHBlYXJzIGF0IHRoZSBzdGFydCBvZiB0aGUgdW5pb24uICBJbiBhbGwgY2FzZXMgdGhlIChzeW50aGVzaXplZClcbiAqIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGluc3RhbmNlIGlzIHJlY29yZGVkIGFzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0geyhMYXlvdXR8bnVsbCl9IGRlZmF1bHRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9LiAgSWYgYWJzZW50IGRlZmF1bHRzIHRvIGBudWxsYC5cbiAqIElmIGBudWxsYCB0aGVyZSBpcyBubyBkZWZhdWx0IGxheW91dDogdGhlIHVuaW9uIGhhcyBkYXRhLWRlcGVuZGVudFxuICogbGVuZ3RoIGFuZCBhdHRlbXB0cyB0byBkZWNvZGUgb3IgZW5jb2RlIHVucmVjb2duaXplZCB2YXJpYW50cyB3aWxsXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uICBBIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIG11c3QgaGF2ZSBhXG4gKiBub24tbmVnYXRpdmUge0BsaW5rIExheW91dCNzcGFufHNwYW59LCBhbmQgaWYgaXQgbGFja3MgYSB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0TGF5b3V0fSB3aWxsIGJlIGEge0BsaW5rXG4gKiBMYXlvdXQjcmVwbGljYXRlfHJlcGxpY2F9IHdpdGggcHJvcGVydHkgYGNvbnRlbnRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVW5pb24gZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCB1cHYgPSAoKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpO1xuICAgIGlmICh1cHYpIHtcbiAgICAgIGRpc2NyID0gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihuZXcgT2Zmc2V0TGF5b3V0KGRpc2NyKSk7XG4gICAgfSBlbHNlIGlmICgoZGlzY3IgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICAgICYmIGRpc2NyLmlzQ291bnQoKSkge1xuICAgICAgZGlzY3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGRpc2NyKTtcbiAgICB9IGVsc2UgaWYgKCEoZGlzY3IgaW5zdGFuY2VvZiBVbmlvbkRpc2NyaW1pbmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaXNjciBtdXN0IGJlIGEgVW5pb25EaXNjcmltaW5hdG9yICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBsYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVmYXVsdExheW91dCkge1xuICAgICAgZGVmYXVsdExheW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghKChudWxsID09PSBkZWZhdWx0TGF5b3V0KVxuICAgICAgICAgIHx8IChkZWZhdWx0TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBiZSBudWxsIG9yIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmIChudWxsICE9PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICBpZiAoMCA+IGRlZmF1bHRMYXlvdXQuc3Bhbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBoYXZlIGNvbnN0YW50IHNwYW4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQucHJvcGVydHkpIHtcbiAgICAgICAgZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQucmVwbGljYXRlKCdjb250ZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogVGhlIHVuaW9uIHNwYW4gY2FuIGJlIGVzdGltYXRlZCBvbmx5IGlmIHRoZXJlJ3MgYSBkZWZhdWx0XG4gICAgICogbGF5b3V0LiAgVGhlIHVuaW9uIHNwYW5zIGl0cyBkZWZhdWx0IGxheW91dCwgcGx1cyBhbnkgcHJlZml4XG4gICAgICogdmFyaWFudCBsYXlvdXQuICBCeSBjb25zdHJ1Y3Rpb24gYm90aCBsYXlvdXRzLCBpZiBwcmVzZW50LCBoYXZlXG4gICAgICogbm9uLW5lZ2F0aXZlIHNwYW4uICovXG4gICAgbGV0IHNwYW4gPSAtMTtcbiAgICBpZiAoZGVmYXVsdExheW91dCkge1xuICAgICAgc3BhbiA9IGRlZmF1bHRMYXlvdXQuc3BhbjtcbiAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiB1cHYpIHtcbiAgICAgICAgc3BhbiArPSBkaXNjci5sYXlvdXQuc3BhbjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGluIGlzb2xhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgYSB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSBlaXRoZXIgcGFzc2VkIHRvIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIG9yIHN5bnRoZXNpemVkIGZyb20gdGhlIGBkaXNjcmAgY29uc3RydWN0b3JcbiAgICAgKiBhcmd1bWVudC4gIHtAbGlua1xuICAgICAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHVzZXNQcmVmaXhEaXNjcmltaW5hdG9yfSB3aWxsIGJlXG4gICAgICogYHRydWVgIGlmZiB0aGUgYGRpc2NyYCBwYXJhbWV0ZXIgd2FzIGEgbm9uLW9mZnNldCB7QGxpbmtcbiAgICAgKiBMYXlvdXR9IGluc3RhbmNlLiAqL1xuICAgIHRoaXMuZGlzY3JpbWluYXRvciA9IGRpc2NyO1xuXG4gICAgLyoqIGB0cnVlYCBpZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaXMgdGhlXG4gICAgICogZmlyc3QgZmllbGQgaW4gdGhlIHVuaW9uLlxuICAgICAqXG4gICAgICogSWYgYGZhbHNlYCB0aGUgZGlzY3JpbWluYXRvciBpcyBvYnRhaW5lZCBmcm9tIHNvbWV3aGVyZVxuICAgICAqIGVsc2UuICovXG4gICAgdGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvciA9IHVwdjtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBub24tZGlzY3JpbWluYXRvciBjb250ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZVxuICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgbm90IHJlY29nbml6ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAgSXQgaXNcbiAgICAgKiBzdHJ1Y3R1cmFsbHkgZXF1aXZhbGVudCB0byB0aGUgc2Vjb25kIGNvbXBvbmVudCBvZiB7QGxpbmtcbiAgICAgKiBVbmlvbiNsYXlvdXR8bGF5b3V0fSBidXQgbWF5IGhhdmUgYSBkaWZmZXJlbnQgcHJvcGVydHlcbiAgICAgKiBuYW1lLiAqL1xuICAgIHRoaXMuZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQ7XG5cbiAgICAvKiogQSByZWdpc3RyeSBvZiBhbGxvd2VkIHZhcmlhbnRzLlxuICAgICAqXG4gICAgICogVGhlIGtleXMgYXJlIHVuc2lnbmVkIGludGVnZXJzIHdoaWNoIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGhcbiAgICAgKiB7QGxpbmsgVW5pb24uZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS4gIFRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIGlzIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBWYXJpYW50TGF5b3V0fSBpbnN0YW5jZXMgYXNzaWduZWRcbiAgICAgKiB0byB0aGlzIHVuaW9uIGJ5IHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9LlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhlIHJlZ2lzdHJ5IHJlbWFpbnMgbXV0YWJsZSBzbyB0aGF0IHZhcmlhbnRzIGNhbiBiZVxuICAgICAqIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZGVkfSBhdCBhbnkgdGltZS4gIFVzZXJzIHNob3VsZCBub3RcbiAgICAgKiBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuICovXG4gICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuXG4gICAgLyogUHJpdmF0ZSB2YXJpYWJsZSB1c2VkIHdoZW4gaW52b2tpbmcgZ2V0U291cmNlVmFyaWFudCAqL1xuICAgIGxldCBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSB0aGlzLmRlZmF1bHRHZXRTb3VyY2VWYXJpYW50LmJpbmQodGhpcyk7XG5cbiAgICAvKiogRnVuY3Rpb24gdG8gaW5mZXIgdGhlIHZhcmlhbnQgc2VsZWN0ZWQgYnkgYSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8ge0BsaW5rXG4gICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9IGJ1dCBtYXlcbiAgICAgKiBiZSBvdmVycmlkZGVuIHVzaW5nIHtAbGlua1xuICAgICAqIFVuaW9uI2NvbmZpZ0dldFNvdXJjZVZhcmlhbnR8Y29uZmlnR2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYXMgd2l0aCB7QGxpbmtcbiAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gVGhlIGRlZmF1bHQgdmFyaWFudFxuICAgICAqIChgdW5kZWZpbmVkYCkgb3IgZmlyc3QgcmVnaXN0ZXJlZCB2YXJpYW50IHRoYXQgdXNlcyBhIHByb3BlcnR5XG4gICAgICogYXZhaWxhYmxlIGluIGBzcmNgLiAqL1xuICAgIHRoaXMuZ2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uKHNyYykge1xuICAgICAgcmV0dXJuIGJvdW5kR2V0U291cmNlVmFyaWFudChzcmMpO1xuICAgIH07XG5cbiAgICAvKiogRnVuY3Rpb24gdG8gb3ZlcnJpZGUgdGhlIGltcGxlbWVudGF0aW9uIG9mIHtAbGlua1xuICAgICAqIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBpZiB0aGUgZGVzaXJlZCB2YXJpYW50IGNhbm5vdCBiZSBpZGVudGlmaWVkIHVzaW5nIHRoZVxuICAgICAqIGFsZ29yaXRobSBvZiB7QGxpbmtcbiAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJvdW5kIHRvIHRoaXNcbiAgICAgKiBVbmlvbiBpbnN0YW5jZSwgcHJvdmlkaW5nIGxvY2FsIGFjY2VzcyB0byB7QGxpbmtcbiAgICAgKiBVbmlvbiNyZWdpc3RyeXxyZWdpc3RyeX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnc3YgLSBhIGZ1bmN0aW9uIHRoYXQgZm9sbG93cyB0aGUgQVBJIG9mXG4gICAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS4gKi9cbiAgICB0aGlzLmNvbmZpZ0dldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbihnc3YpIHtcbiAgICAgIGJvdW5kR2V0U291cmNlVmFyaWFudCA9IGdzdi5iaW5kKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIC8qIERlZmF1bHQgbGF5b3V0cyBhbHdheXMgaGF2ZSBub24tbmVnYXRpdmUgc3Bhbiwgc28gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIG9uZSBhbmQgd2UgaGF2ZSB0byByZWNvZ25pemUgdGhlIHZhcmlhbnQgd2hpY2ggd2lsbCBpbiB0dXJuXG4gICAgICogZGV0ZXJtaW5lIHRoZSBzcGFuLiAqL1xuICAgIGNvbnN0IHZsbyA9IHRoaXMuZ2V0VmFyaWFudChiLCBvZmZzZXQpO1xuICAgIGlmICghdmxvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZXRlcm1pbmUgc3BhbiBmb3IgdW5yZWNvZ25pemVkIHZhcmlhbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZsby5nZXRTcGFuKGIsIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGluZmVyIGEgcmVnaXN0ZXJlZCBVbmlvbiB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBgc3JjYC5cbiAgICpcbiAgICogVGhlIGZpcnN0IHNhdGlzaWZpZWQgcnVsZSBpbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIGRlZmluZXMgdGhlXG4gICAqIHJldHVybiB2YWx1ZTpcbiAgICogKiBJZiBgc3JjYCBoYXMgcHJvcGVydGllcyBtYXRjaGluZyB0aGUgVW5pb24gZGlzY3JpbWluYXRvciBhbmRcbiAgICogICB0aGUgZGVmYXVsdCBsYXlvdXQsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAqICAgdmFsdWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkgKHRoaXMgZW5zdXJlcyB0aGUgZGVmYXVsdFxuICAgKiAgIGxheW91dCB3aWxsIGJlIHVzZWQpO1xuICAgKiAqIElmIGBzcmNgIGhhcyBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yLCB0aGVcbiAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBpZGVudGlmaWVzIGEgcmVnaXN0ZXJlZCB2YXJpYW50LCBhbmRcbiAgICogICBlaXRoZXIgKGEpIHRoZSB2YXJpYW50IGhhcyBubyBsYXlvdXQsIG9yIChiKSBgc3JjYCBoYXMgdGhlXG4gICAqICAgdmFyaWFudCdzIHByb3BlcnR5LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZVxuICAgKiAgIHNvdXJjZSBzYXRpc2ZpZXMgdGhlIGNvbnN0cmFpbnRzIG9mIHRoZSB2YXJpYW50IGl0IGlkZW50aWZpZXMpO1xuICAgKiAqIElmIGBzcmNgIGRvZXMgbm90IGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgVW5pb25cbiAgICogICBkaXNjcmltaW5hdG9yLCBidXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgYSByZWdpc3RlcmVkXG4gICAqICAgdmFyaWFudCwgdGhlbiB0aGUgdmFyaWFudCBpcyByZXR1cm5lZCAoYmVjYXVzZSB0aGUgc291cmNlXG4gICAqICAgbWF0Y2hlcyBhIHZhcmlhbnQgd2l0aG91dCBhbiBleHBsaWNpdCBjb25mbGljdCk7XG4gICAqICogQW4gZXJyb3IgaXMgdGhyb3duIChiZWNhdXNlIHdlIGVpdGhlciBjYW4ndCBpZGVudGlmeSBhIHZhcmlhbnQsXG4gICAqICAgb3Igd2Ugd2VyZSBleHBsaWNpdGx5IHRvbGQgdGhlIHZhcmlhbnQgYnV0IGNhbid0IHNhdGlzZnkgaXQpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYW4gb2JqZWN0IHByZXN1bWVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgKiB0aGUgY29udGVudCBvZiB0aGUgVW5pb24uXG4gICAqXG4gICAqIEByZXR1cm4geyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IC0gYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgc3JjYCBjYW5ub3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgZGVmYXVsdCBvclxuICAgKiByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAqL1xuICBkZWZhdWx0R2V0U291cmNlVmFyaWFudChzcmMpIHtcbiAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KHRoaXMuZGlzY3JpbWluYXRvci5wcm9wZXJ0eSkpIHtcbiAgICAgIGlmICh0aGlzLmRlZmF1bHRMYXlvdXRcbiAgICAgICAgICAmJiBzcmMuaGFzT3duUHJvcGVydHkodGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVtzcmNbdGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5XV07XG4gICAgICBpZiAodmxvXG4gICAgICAgICAgJiYgKCghdmxvLmxheW91dClcbiAgICAgICAgICAgICAgfHwgc3JjLmhhc093blByb3BlcnR5KHZsby5wcm9wZXJ0eSkpKSB7XG4gICAgICAgIHJldHVybiB2bG87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgdGFnIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVt0YWddO1xuICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KHZsby5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGluZmVyIHNyYyB2YXJpYW50Jyk7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAqXG4gICAqIElmIHRoZSB2YXJpYW50IGlzIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fHJlZ2lzdGVyZWR9IHRoZSByZXR1cm5cbiAgICogdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB2YXJpYW50LCB3aXRoIG5vIGV4cGxpY2l0XG4gICAqIGRpc2NyaW1pbmF0b3IuICBPdGhlcndpc2UgdGhlIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRcbiAgICogbGF5b3V0fSBpcyB1c2VkIHRvIGRlY29kZSB0aGUgY29udGVudC4gKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IGRlc3Q7XG4gICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgIGNvbnN0IGRpc2NyID0gZGxvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIGxldCBjbG8gPSB0aGlzLnJlZ2lzdHJ5W2Rpc2NyXTtcbiAgICBpZiAodW5kZWZpbmVkID09PSBjbG8pIHtcbiAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgIGNsbyA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICB9XG4gICAgICBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgIGRlc3RbZGxvLnByb3BlcnR5XSA9IGRpc2NyO1xuICAgICAgZGVzdFtjbG8ucHJvcGVydHldID0gdGhpcy5kZWZhdWx0TGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdCA9IGNsby5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAqXG4gICAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGBzcmNgIG9iamVjdCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHVuaW9uJ3NcbiAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LiAgVG8gZW5jb2RlIHZhcmlhbnRzXG4gICAqIHVzZSB0aGUgYXBwcm9wcmlhdGUgdmFyaWFudC1zcGVjaWZpYyB7QGxpbmsgVmFyaWFudExheW91dCNlbmNvZGV9XG4gICAqIG1ldGhvZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCB2bG8gPSB0aGlzLmdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICBpZiAodW5kZWZpbmVkID09PSB2bG8pIHtcbiAgICAgIGNvbnN0IGRsbyA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgIGNvbnN0IGNsbyA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICB9XG4gICAgICBkbG8uZW5jb2RlKHNyY1tkbG8ucHJvcGVydHldLCBiLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBjbG8uZW5jb2RlKHNyY1tjbG8ucHJvcGVydHldLCBiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdmxvLmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogUmVnaXN0ZXIgYSBuZXcgdmFyaWFudCBzdHJ1Y3R1cmUgd2l0aGluIGEgdW5pb24uICBUaGUgbmV3bHlcbiAgICogY3JlYXRlZCB2YXJpYW50IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICAgKlxuICAgKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAqXG4gICAqIEByZXR1cm4ge1ZhcmlhbnRMYXlvdXR9ICovXG4gIGFkZFZhcmlhbnQodmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHJ2ID0gbmV3IFZhcmlhbnRMYXlvdXQodGhpcywgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSk7XG4gICAgdGhpcy5yZWdpc3RyeVt2YXJpYW50XSA9IHJ2O1xuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAqXG4gICAqIElmIGB2YmAgZG9lcyBub3QgcHJvZHVjZSBhIHJlZ2lzdGVyZWQgdmFyaWFudCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICAgKiBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQHBhcmFtIHsoTnVtYmVyfEJ1ZmZlcil9IHZiIC0gZWl0aGVyIHRoZSB2YXJpYW50IG51bWJlciwgb3IgYVxuICAgKiBidWZmZXIgZnJvbSB3aGljaCB0aGUgZGlzY3JpbWluYXRvciBpcyB0byBiZSByZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IC0gb2Zmc2V0IGludG8gYHZiYCBmb3IgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiB1bmlvbi4gIFVzZWQgb25seSB3aGVuIGB2YmAgaXMgYW4gaW5zdGFuY2Ugb2Yge0J1ZmZlcn0uXG4gICAqXG4gICAqIEByZXR1cm4geyh7VmFyaWFudExheW91dH18dW5kZWZpbmVkKX1cbiAgICovXG4gIGdldFZhcmlhbnQodmIsIG9mZnNldCkge1xuICAgIGxldCB2YXJpYW50ID0gdmI7XG4gICAgaWYgKGJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIodmIpKSB7XG4gICAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhcmlhbnQgPSB0aGlzLmRpc2NyaW1pbmF0b3IuZGVjb2RlKHZiLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVt2YXJpYW50XTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNwZWNpZmljIHZhcmlhbnQgd2l0aGluIGEgY29udGFpbmluZyB1bmlvbi5cbiAqXG4gKiAqKk5PVEUqKiBUaGUge0BsaW5rIExheW91dCNzcGFufHNwYW59IG9mIHRoZSB2YXJpYW50IG1heSBpbmNsdWRlXG4gKiB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gdXNlZCB0b1xuICogaWRlbnRpZnkgaXQsIGJ1dCB2YWx1ZXMgcmVhZCBhbmQgd3JpdHRlbiB1c2luZyB0aGUgdmFyaWFudCBzdHJpY3RseVxuICogY29uZm9ybSB0byB0aGUgY29udGVudCBvZiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gIFVzZVxuICogdGhlIHVuaW9uIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9IGhlbHBlciBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtVbmlvbn0gdW5pb24gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I3VuaW9ufHVuaW9ufS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdmFyaWFudHx2YXJpYW50fS5cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gW2xheW91dF0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAgSWYgYWJzZW50IHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAqIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LiAgVW5saWtlIG1hbnkgb3RoZXIgbGF5b3V0cywgdmFyaWFudFxuICogbGF5b3V0cyBub3JtYWxseSBpbmNsdWRlIGEgcHJvcGVydHkgbmFtZSBzbyB0aGV5IGNhbiBiZSBpZGVudGlmaWVkXG4gKiB3aXRoaW4gdGhlaXIgY29udGFpbmluZyB7QGxpbmsgVW5pb259LiAgVGhlIHByb3BlcnR5IGlkZW50aWZpZXIgbWF5XG4gKiBiZSBhYnNlbnQgb25seSBpZiBgbGF5b3V0YCBpcyBpcyBhYnNlbnQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFZhcmlhbnRMYXlvdXQgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcih1bmlvbiwgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgIGlmICghKHVuaW9uIGluc3RhbmNlb2YgVW5pb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmlvbiBtdXN0IGJlIGEgVW5pb24nKTtcbiAgICB9XG4gICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcih2YXJpYW50KSkgfHwgKDAgPiB2YXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBtdXN0IGJlIGEgKG5vbi1uZWdhdGl2ZSkgaW50ZWdlcicpO1xuICAgIH1cbiAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbGF5b3V0KVxuICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgIHByb3BlcnR5ID0gbGF5b3V0O1xuICAgICAgbGF5b3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgaWYgKCEobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgICAgfVxuICAgICAgaWYgKChudWxsICE9PSB1bmlvbi5kZWZhdWx0TGF5b3V0KVxuICAgICAgICAgICYmICgwIDw9IGxheW91dC5zcGFuKVxuICAgICAgICAgICYmIChsYXlvdXQuc3BhbiA+IHVuaW9uLmRlZmF1bHRMYXlvdXQuc3BhbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW50IHNwYW4gZXhjZWVkcyBzcGFuIG9mIGNvbnRhaW5pbmcgdW5pb24nKTtcbiAgICAgIH1cbiAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbXVzdCBoYXZlIGEgU3RyaW5nIHByb3BlcnR5Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzcGFuID0gdW5pb24uc3BhbjtcbiAgICBpZiAoMCA+IHVuaW9uLnNwYW4pIHtcbiAgICAgIHNwYW4gPSBsYXlvdXQgPyBsYXlvdXQuc3BhbiA6IDA7XG4gICAgICBpZiAoKDAgPD0gc3BhbikgJiYgdW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgc3BhbiArPSB1bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIHtAbGluayBVbmlvbn0gdG8gd2hpY2ggdGhpcyB2YXJpYW50IGJlbG9uZ3MuICovXG4gICAgdGhpcy51bmlvbiA9IHVuaW9uO1xuXG4gICAgLyoqIFRoZSB1bnNpZ25lZCBpbnRlZ3JhbCB2YWx1ZSBpZGVudGlmeWluZyB0aGlzIHZhcmlhbnQgd2l0aGluXG4gICAgICogdGhlIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IG9mIHRoZSBjb250YWluaW5nXG4gICAgICogdW5pb24uICovXG4gICAgdGhpcy52YXJpYW50ID0gdmFyaWFudDtcblxuICAgIC8qKiBUaGUge0BsaW5rIExheW91dH0gdG8gYmUgdXNlZCB3aGVuIHJlYWRpbmcvd3JpdGluZyB0aGVcbiAgICAgKiBub24tZGlzY3JpbWluYXRvciBwYXJ0IG9mIHRoZSB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I3VuaW9ufHVuaW9ufS4gIElmIGBudWxsYCB0aGUgdmFyaWFudCBjYXJyaWVzIG5vXG4gICAgICogZGF0YS4gKi9cbiAgICB0aGlzLmxheW91dCA9IGxheW91dCB8fCBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgLyogV2lsbCBiZSBlcXVhbCB0byB0aGUgY29udGFpbmluZyB1bmlvbiBzcGFuIGlmIHRoYXQgaXMgbm90XG4gICAgICAgKiB2YXJpYWJsZS4gKi9cbiAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgIH1cbiAgICAvKiBTcGFuIGlzIGRlZmluZWQgc29sZWx5IGJ5IHRoZSB2YXJpYW50IChhbmQgcHJlZml4IGRpc2NyaW1pbmF0b3IpICovXG4gICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcyAhPT0gdGhpcy51bmlvbi5nZXRWYXJpYW50KGIsIG9mZnNldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFudCBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgfVxuICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJvcGVydHkpIHtcbiAgICAgIGRlc3RbdGhpcy5wcm9wZXJ0eV0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgZGVzdFt0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IucHJvcGVydHldID0gdGhpcy52YXJpYW50O1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgfVxuICAgIGlmICh0aGlzLmxheW91dFxuICAgICAgICAmJiAoIXNyYy5oYXNPd25Qcm9wZXJ0eSh0aGlzLnByb3BlcnR5KSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbGFja3MgcHJvcGVydHkgJyArIHRoaXMucHJvcGVydHkpO1xuICAgIH1cbiAgICB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IuZW5jb2RlKHRoaXMudmFyaWFudCwgYiwgb2Zmc2V0KTtcbiAgICBsZXQgc3BhbiA9IGNvbnRlbnRPZmZzZXQ7XG4gICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICB0aGlzLmxheW91dC5lbmNvZGUoc3JjW3RoaXMucHJvcGVydHldLCBiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgIHNwYW4gKz0gdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgIGlmICgoMCA8PSB0aGlzLnVuaW9uLnNwYW4pXG4gICAgICAgICAgJiYgKHNwYW4gPiB0aGlzLnVuaW9uLnNwYW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5jb2RlZCB2YXJpYW50IG92ZXJydW5zIGNvbnRhaW5pbmcgdW5pb24nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cblxuICAvKiogRGVsZWdhdGUge0BsaW5rIExheW91dCNmcm9tQXJyYXl8ZnJvbUFycmF5fSB0byB7QGxpbmtcbiAgICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmZyb21BcnJheSh2YWx1ZXMpO1xuICAgIH1cbiAgfVxufVxuXG4vKiogSmF2YVNjcmlwdCBjaG9zZSB0byBkZWZpbmUgYml0d2lzZSBvcGVyYXRpb25zIGFzIG9wZXJhdGluZyBvblxuICogc2lnbmVkIDMyLWJpdCB2YWx1ZXMgaW4gMidzIGNvbXBsZW1lbnQgZm9ybSwgbWVhbmluZyBhbnkgaW50ZWdlclxuICogd2l0aCBiaXQgMzEgc2V0IGlzIGdvaW5nIHRvIGxvb2sgbmVnYXRpdmUuICBGb3IgcmlnaHQgc2hpZnRzIHRoYXQnc1xuICogbm90IGEgcHJvYmxlbSwgYmVjYXVzZSBgPj4+YCBpcyBhIGxvZ2ljYWwgc2hpZnQsIGJ1dCBmb3IgZXZlcnlcbiAqIG90aGVyIGJpdHdpc2Ugb3BlcmF0b3Igd2UgaGF2ZSB0byBjb21wZW5zYXRlIGZvciBwb3NzaWJsZSBuZWdhdGl2ZVxuICogcmVzdWx0cy4gKi9cbmZ1bmN0aW9uIGZpeEJpdHdpc2VSZXN1bHQodikge1xuICBpZiAoMCA+IHYpIHtcbiAgICB2ICs9IDB4MTAwMDAwMDAwO1xuICB9XG4gIHJldHVybiB2O1xufVxuXG4vKipcbiAqIENvbnRhaW4gYSBzZXF1ZW5jZSBvZiBiaXQgZmllbGRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5iaXRzfGJpdHN9XG4gKlxuICogVGhpcyBpcyBhIGNvbnRhaW5lciBlbGVtZW50OyB3aXRoaW4gaXQgdGhlcmUgYXJlIHtAbGluayBCaXRGaWVsZH1cbiAqIGluc3RhbmNlcyB0aGF0IHByb3ZpZGUgdGhlIGV4dHJhY3RlZCBwcm9wZXJ0aWVzLiAgVGhlIGNvbnRhaW5lclxuICogc2ltcGx5IGRlZmluZXMgdGhlIGFnZ3JlZ2F0ZSByZXByZXNlbnRhdGlvbiBhbmQgaXRzIGJpdCBvcmRlcmluZy5cbiAqIFRoZSByZXByZXNlbnRhdGlvbiBpcyBhbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHdpdGggbnVtZXJpY1xuICogb3Ige0BsaW5rIEJvb2xlYW59IHZhbHVlcy5cbiAqXG4gKiB7QGxpbmsgQml0RmllbGR9cyBhcmUgYWRkZWQgd2l0aCB0aGUge0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGFuZCB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IG1ldGhvZHMuXG5cbiAqIEBwYXJhbSB7TGF5b3V0fSB3b3JkIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0U3RydWN0dXJlI3dvcmR8d29yZH0uICBUaGUgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2ZcbiAqIHtAbGluayBVSW50fSAob3Ige0BsaW5rIFVJbnRCRX0pIHRoYXQgaXMgbm8gbW9yZSB0aGFuIDQgYnl0ZXMgd2lkZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2x9IFttc2JdIC0gYHRydWVgIGlmIHRoZSBiaXQgbnVtYmVyaW5nIHN0YXJ0cyBhdCB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBjb250YWluaW5nIHdvcmQ7IGBmYWxzZWAgKGRlZmF1bHQpIGlmXG4gKiBpdCBzdGFydHMgYXQgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgY29udGFpbmluZyB3b3JkLiAgSWZcbiAqIHRoZSBwYXJhbWV0ZXIgYXQgdGhpcyBwb3NpdGlvbiBpcyBhIHN0cmluZyBhbmQgYHByb3BlcnR5YCBpc1xuICogYHVuZGVmaW5lZGAgdGhlIHZhbHVlIG9mIHRoaXMgYXJndW1lbnQgd2lsbCBpbnN0ZWFkIGJlIHVzZWQgYXMgdGhlXG4gKiB2YWx1ZSBvZiBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQml0U3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3Iod29yZCwgbXNiLCBwcm9wZXJ0eSkge1xuICAgIGlmICghKCh3b3JkIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICB8fCAod29yZCBpbnN0YW5jZW9mIFVJbnRCRSkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3b3JkIG11c3QgYmUgYSBVSW50IG9yIFVJbnRCRSBsYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIG1zYilcbiAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICBwcm9wZXJ0eSA9IG1zYjtcbiAgICAgIG1zYiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKDQgPCB3b3JkLnNwYW4pIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3b3JkIGNhbm5vdCBleGNlZWQgMzIgYml0cycpO1xuICAgIH1cbiAgICBzdXBlcih3b3JkLnNwYW4sIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbGF5b3V0IHVzZWQgZm9yIHRoZSBwYWNrZWQgdmFsdWUuICB7QGxpbmsgQml0RmllbGR9XG4gICAgICogaW5zdGFuY2VzIGFyZSBwYWNrZWQgc2VxdWVudGlhbGx5IGRlcGVuZGluZyBvbiB7QGxpbmtcbiAgICAgKiBCaXRTdHJ1Y3R1cmUjbXNifG1zYn0uICovXG4gICAgdGhpcy53b3JkID0gd29yZDtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBiaXQgc2VxdWVuY2VzIGFyZSBwYWNrZWQgc3RhcnRpbmcgYXQgdGhlIG1vc3RcbiAgICAgKiBzaWduaWZpY2FudCBiaXQgZ3Jvd2luZyBkb3duIChgdHJ1ZWApLCBvciB0aGUgbGVhc3Qgc2lnbmlmaWNhbnRcbiAgICAgKiBiaXQgZ3Jvd2luZyB1cCAoYGZhbHNlYCkuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBSZWdhcmRsZXNzIG9mIHRoaXMgdmFsdWUsIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2ZcbiAgICAgKiBhbnkge0BsaW5rIEJpdEZpZWxkfSB2YWx1ZSBpcyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgc2VjdGlvbiBvZiB0aGUgcGFja2VkIHZhbHVlLiAqL1xuICAgIHRoaXMubXNiID0gISFtc2I7XG5cbiAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBCaXRGaWVsZH0gbGF5b3V0cyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAqIHBhY2tlZCBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGUgYXJyYXkgcmVtYWlucyBtdXRhYmxlIHRvIGFsbG93IGZpZWxkcyB0byBiZSB7QGxpbmtcbiAgICAgKiBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkZWR9IGFmdGVyIGNvbnN0cnVjdGlvbi4gIFVzZXJzIHNob3VsZFxuICAgICAqIG5vdCBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuKi9cbiAgICB0aGlzLmZpZWxkcyA9IFtdO1xuXG4gICAgLyogU3RvcmFnZSBmb3IgdGhlIHZhbHVlLiAgQ2FwdHVyZSBhIHZhcmlhYmxlIGluc3RlYWQgb2YgdXNpbmcgYW5cbiAgICAgKiBpbnN0YW5jZSBwcm9wZXJ0eSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYW55dGhpbmcgdG8gY2hhbmdlIHRoZVxuICAgICAqIHZhbHVlIHdpdGhvdXQgZ29pbmcgdGhyb3VnaCB0aGUgbXV0YXRvci4gKi9cbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlID0gZnVuY3Rpb24odikge1xuICAgICAgdmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHYpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLl9wYWNrZWRHZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy53b3JkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlKHZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IGZkLmRlY29kZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAgICpcbiAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUgY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIHBhY2tlZFxuICAgKiB2YWx1ZSBpcyBsZWZ0IHVubW9kaWZpZWQuICBVbnVzZWQgYml0cyBhcmUgYWxzbyBsZWZ0IHVubW9kaWZpZWQuICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgdGhpcy5fcGFja2VkU2V0VmFsdWUodmFsdWUpO1xuICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IGZ2ID0gc3JjW2ZkLnByb3BlcnR5XTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnYpIHtcbiAgICAgICAgICBmZC5lbmNvZGUoZnYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmQuZW5jb2RlKHRoaXMuX3BhY2tlZEdldFZhbHVlKCksIGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogUmVnaXN0ZXIgYSBuZXcgYml0ZmllbGQgd2l0aCBhIGNvbnRhaW5pbmcgYml0IHN0cnVjdHVyZS4gIFRoZVxuICAgKiByZXN1bHRpbmcgYml0ZmllbGQgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBiaXRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAqXG4gICAqIEByZXR1cm4ge0JpdEZpZWxkfSAqL1xuICBhZGRGaWVsZChiaXRzLCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IGJmID0gbmV3IEJpdEZpZWxkKHRoaXMsIGJpdHMsIHByb3BlcnR5KTtcbiAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICByZXR1cm4gYmY7XG4gIH1cblxuICAvKiogQXMgd2l0aCB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBmb3Igc2luZ2xlLWJpdFxuICAgKiBmaWVsZHMgd2l0aCBgYm9vbGVhbmAgdmFsdWUgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gKi9cbiAgYWRkQm9vbGVhbihwcm9wZXJ0eSkge1xuICAgIC8vIFRoaXMgaXMgbXkgQm9vbGVhbiwgbm90IHRoZSBKYXZhc2NyaXB0IG9uZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgY29uc3QgYmYgPSBuZXcgQm9vbGVhbih0aGlzLCBwcm9wZXJ0eSk7XG4gICAgdGhpcy5maWVsZHMucHVzaChiZik7XG4gICAgcmV0dXJuIGJmO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhY2Nlc3MgdG8gdGhlIGJpdCBmaWVsZCBmb3IgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIGJpdCBmaWVsZCBvZiBpbnRlcmVzdC5cbiAgICpcbiAgICogQHJldHVybiB7Qml0RmllbGR9IC0gdGhlIGZpZWxkIGFzc29jaWF0ZWQgd2l0aCBgcHJvcGVydHlgLCBvclxuICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICovXG4gIGZpZWxkRm9yKHByb3BlcnR5KSB7XG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIGJpdHMgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0uXG4gKlxuICogQWxsIGJpdCBmaWVsZCB2YWx1ZXMgYXJlIHJlcHJlc2VudGVkIGFzIHVuc2lnbmVkIGludGVnZXJzLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gaGVscGVyXG4gKiBtZXRob2QuXG4gKlxuICogKipOT1RFKiogQml0RmllbGQgaW5zdGFuY2VzIGFyZSBub3QgaW5zdGFuY2VzIG9mIHtAbGluayBMYXlvdXR9XG4gKiBzaW5jZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gbWVhc3VyZXMgOC1iaXQgdW5pdHMuXG4gKlxuICogQHBhcmFtIHtCaXRTdHJ1Y3R1cmV9IGNvbnRhaW5lciAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdEZpZWxkI2NvbnRhaW5lcnxjb250YWluZXJ9LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBiaXRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqL1xuY2xhc3MgQml0RmllbGQge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGJpdHMsIHByb3BlcnR5KSB7XG4gICAgaWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgQml0U3RydWN0dXJlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29udGFpbmVyIG11c3QgYmUgYSBCaXRTdHJ1Y3R1cmUnKTtcbiAgICB9XG4gICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcihiaXRzKSkgfHwgKDAgPj0gYml0cykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JpdHMgbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsQml0cyA9IDggKiBjb250YWluZXIuc3BhbjtcbiAgICBjb25zdCB1c2VkQml0cyA9IGNvbnRhaW5lci5maWVsZHMucmVkdWNlKChzdW0sIGZkKSA9PiBzdW0gKyBmZC5iaXRzLCAwKTtcbiAgICBpZiAoKGJpdHMgKyB1c2VkQml0cykgPiB0b3RhbEJpdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYml0cyB0b28gbG9uZyBmb3Igc3BhbiByZW1haW5kZXIgKCdcbiAgICAgICAgICAgICAgICAgICAgICArICh0b3RhbEJpdHMgLSB1c2VkQml0cykgKyAnIG9mICdcbiAgICAgICAgICAgICAgICAgICAgICArIHRvdGFsQml0cyArICcgcmVtYWluKScpO1xuICAgIH1cblxuICAgIC8qKiBUaGUge0BsaW5rIEJpdFN0cnVjdHVyZX0gaW5zdGFuY2UgdG8gd2hpY2ggdGhpcyBiaXQgZmllbGRcbiAgICAgKiBiZWxvbmdzLiAqL1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgLyoqIFRoZSBzcGFuIG9mIHRoaXMgdmFsdWUgaW4gYml0cy4gKi9cbiAgICB0aGlzLmJpdHMgPSBiaXRzO1xuXG4gICAgLyoqIEEgbWFzayBvZiB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfSBiaXRzIGlzb2xhdGluZyB2YWx1ZSBiaXRzXG4gICAgICogdGhhdCBmaXQgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKlxuICAgICAqIFRoYXQgaXMsIGl0IG1hc2tzIGEgdmFsdWUgdGhhdCBoYXMgbm90IHlldCBiZWVuIHNoaWZ0ZWQgaW50b1xuICAgICAqIHBvc2l0aW9uIHdpdGhpbiBpdHMgY29udGFpbmluZyBwYWNrZWQgaW50ZWdlci4gKi9cbiAgICB0aGlzLnZhbHVlTWFzayA9ICgxIDw8IGJpdHMpIC0gMTtcbiAgICBpZiAoMzIgPT09IGJpdHMpIHsgLy8gc2hpZnRlZCB2YWx1ZSBvdXQgb2YgcmFuZ2VcbiAgICAgIHRoaXMudmFsdWVNYXNrID0gMHhGRkZGRkZGRjtcbiAgICB9XG5cbiAgICAvKiogVGhlIG9mZnNldCBvZiB0aGUgdmFsdWUgd2l0aGluIHRoZSBjb250YWluaW5nIHBhY2tlZCB1bnNpZ25lZFxuICAgICAqIGludGVnZXIuICBUaGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBwYWNrZWQgdmFsdWUgaXMgYXRcbiAgICAgKiBvZmZzZXQgemVybywgcmVnYXJkbGVzcyBvZiBiaXQgb3JkZXJpbmcgdXNlZC4gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdXNlZEJpdHM7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyLm1zYikge1xuICAgICAgdGhpcy5zdGFydCA9IHRvdGFsQml0cyAtIHVzZWRCaXRzIC0gYml0cztcbiAgICB9XG5cbiAgICAvKiogQSBtYXNrIG9mIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9IGlzb2xhdGluZyB0aGUgZmllbGQgdmFsdWVcbiAgICAgKiB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgcGFja2VkIHVuc2lnbmVkIGludGVnZXIuICovXG4gICAgdGhpcy53b3JkTWFzayA9IGZpeEJpdHdpc2VSZXN1bHQodGhpcy52YWx1ZU1hc2sgPDwgdGhpcy5zdGFydCk7XG5cbiAgICAvKiogVGhlIHByb3BlcnR5IG5hbWUgdXNlZCB3aGVuIHRoaXMgYml0ZmllbGQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgKiBPYmplY3QuXG4gICAgICpcbiAgICAgKiBJbnRlbmRlZCB0byBiZSBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl9LlxuICAgICAqXG4gICAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIGNvcnJlc3BvbmRpbmcgc3BhbiBvZiBiaXRzIHdpbGwgYmVcbiAgICAgKiB0cmVhdGVkIGFzIHBhZGRpbmc6IGl0IHdpbGwgbm90IGJlIG11dGF0ZWQgYnkge0BsaW5rXG4gICAgICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG5vciByZXByZXNlbnRlZCBhcyBhIHByb3BlcnR5IGluIHRoZVxuICAgICAqIGRlY29kZWQgT2JqZWN0LiAqL1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgfVxuXG4gIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICogYml0IGZpZWxkLiAqL1xuICBkZWNvZGUoKSB7XG4gICAgY29uc3Qgd29yZCA9IHRoaXMuY29udGFpbmVyLl9wYWNrZWRHZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHdvcmRWYWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQod29yZCAmIHRoaXMud29yZE1hc2spO1xuICAgIGNvbnN0IHZhbHVlID0gd29yZFZhbHVlID4+PiB0aGlzLnN0YXJ0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICogYml0IGZpZWxkLlxuICAgKlxuICAgKiAqKk5PVEUqKiBUaGlzIGlzIG5vdCBhIHNwZWNpYWxpemF0aW9uIG9mIHtAbGlua1xuICAgKiBMYXlvdXQjZW5jb2RlfExheW91dC5lbmNvZGV9IGFuZCB0aGVyZSBpcyBubyByZXR1cm4gdmFsdWUuICovXG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIodmFsdWUpKVxuICAgICAgICB8fCAodmFsdWUgIT09IGZpeEJpdHdpc2VSZXN1bHQodmFsdWUgJiB0aGlzLnZhbHVlTWFzaykpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWVXaXRoUHJvcGVydHkoJ0JpdEZpZWxkLmVuY29kZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJyB2YWx1ZSBtdXN0IGJlIGludGVnZXIgbm90IGV4Y2VlZGluZyAnICsgdGhpcy52YWx1ZU1hc2spO1xuICAgIH1cbiAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSA8PCB0aGlzLnN0YXJ0KTtcbiAgICB0aGlzLmNvbnRhaW5lci5fcGFja2VkU2V0VmFsdWUoZml4Qml0d2lzZVJlc3VsdCh3b3JkICYgfnRoaXMud29yZE1hc2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgd29yZFZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzaW5nbGUgYml0IHdpdGhpbiBhIHtAbGluayBCaXRTdHJ1Y3R1cmV9IGFzIGFcbiAqIEphdmFTY3JpcHQgYm9vbGVhbi5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqIFVzZSB0aGUgY29udGFpbmVyIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkQm9vbGVhbnxhZGRCb29sZWFufSBoZWxwZXJcbiAqIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0JpdFN0cnVjdHVyZX0gY29udGFpbmVyIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0RmllbGQjY29udGFpbmVyfGNvbnRhaW5lcn0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7Qml0RmllbGR9XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cbmNsYXNzIEJvb2xlYW4gZXh0ZW5kcyBCaXRGaWVsZCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgcHJvcGVydHkpIHtcbiAgICBzdXBlcihjb250YWluZXIsIDEsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBPdmVycmlkZSB7QGxpbmsgQml0RmllbGQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBCb29sZWFufEJvb2xlYW59LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIHJldHVybiAhIUJpdEZpZWxkLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzLCBiLCBvZmZzZXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUodmFsdWUpIHtcbiAgICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgIC8vIEJpdEZpZWxkIHJlcXVpcmVzIGludGVnZXIgdmFsdWVzXG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIEJpdEZpZWxkLnByb3RvdHlwZS5lbmNvZGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuXG4vKipcbiAqIENvbnRhaW4gYSBmaXhlZC1sZW5ndGggYmxvY2sgb2YgYXJiaXRyYXJ5IGRhdGEsIHJlcHJlc2VudGVkIGFzIGFcbiAqIEJ1ZmZlci5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmJsb2J8YmxvYn1cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBsZW5ndGggLSBpbml0aWFsaXplcyB7QGxpbmtcbiAqIEJsb2IjbGVuZ3RofGxlbmd0aH0uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBCbG9iIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBwcm9wZXJ0eSkge1xuICAgIGlmICghKCgobGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpICYmIGxlbmd0aC5pc0NvdW50KCkpXG4gICAgICAgICAgfHwgKE51bWJlci5pc0ludGVnZXIobGVuZ3RoKSAmJiAoMCA8PSBsZW5ndGgpKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xlbmd0aCBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0Jyk7XG4gICAgfVxuXG4gICAgbGV0IHNwYW4gPSAtMTtcbiAgICBpZiAoIShsZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpIHtcbiAgICAgIHNwYW4gPSBsZW5ndGg7XG4gICAgfVxuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBibG9iLlxuICAgICAqXG4gICAgICogVGhpcyBtYXkgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgb3IgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICAgICAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfS4gKi9cbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBsZXQgc3BhbiA9IHRoaXMuc3BhbjtcbiAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgIHNwYW4gPSB0aGlzLmxlbmd0aC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gYi5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4pO1xuICB9XG5cbiAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgQmxvYn0uXG4gICAqXG4gICAqICoqTk9URSoqIElmIHtAbGluayBMYXlvdXQjY291bnR8Y291bnR9IGlzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgbGV0IHNwYW4gPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgc3BhbiA9IHNyYy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICghKGJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoc3JjKVxuICAgICAgICAgICYmIChzcGFuID09PSBzcmMubGVuZ3RoKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQmxvYi5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICArICcgcmVxdWlyZXMgKGxlbmd0aCAnICsgc3BhbiArICcpIEJ1ZmZlciBhcyBzcmMnKTtcbiAgICB9XG4gICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgfVxuICAgIGIud3JpdGUoc3JjLnRvU3RyaW5nKCdoZXgnKSwgb2Zmc2V0LCBzcGFuLCAnaGV4Jyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgIHRoaXMubGVuZ3RoLmVuY29kZShzcGFuLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW4gYSBgTlVMYC10ZXJtaW5hdGVkIFVURjggc3RyaW5nLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY3N0cnxjc3RyfVxuICpcbiAqICoqTk9URSoqIEFueSBVVEY4IHN0cmluZyB0aGF0IGluY29ycG9yYXRlcyBhIHplcm8tdmFsdWVkIGJ5dGUgd2lsbFxuICogbm90IGJlIGNvcnJlY3RseSBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ1N0cmluZyBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoIWJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2IgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBpZHggPSBvZmZzZXQ7XG4gICAgd2hpbGUgKChpZHggPCBiLmxlbmd0aCkgJiYgKDAgIT09IGJbaWR4XSkpIHtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gMSArIGlkeCAtIG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCwgZGVzdCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gYi5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4gLSAxKS50b1N0cmluZygndXRmLTgnKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAqIHNyYyAqL1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgc3JjID0gc3JjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHNyY2IgPSBuZXcgYnVmZmVyLkJ1ZmZlcihzcmMsICd1dGY4Jyk7XG4gICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBzcmNiLmNvcHkoYiwgb2Zmc2V0KTtcbiAgICBiW29mZnNldCArIHNwYW5dID0gMDtcbiAgICByZXR1cm4gc3BhbiArIDE7XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWluIGEgVVRGOCBzdHJpbmcgd2l0aCBpbXBsaWNpdCBsZW5ndGguXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51dGY4fHV0Zjh9XG4gKlxuICogKipOT1RFKiogQmVjYXVzZSB0aGUgbGVuZ3RoIGlzIGltcGxpY2l0IGluIHRoZSBzaXplIG9mIHRoZSBidWZmZXJcbiAqIHRoaXMgbGF5b3V0IHNob3VsZCBiZSB1c2VkIG9ubHkgaW4gaXNvbGF0aW9uLCBvciBpbiBhIHNpdHVhdGlvblxuICogd2hlcmUgdGhlIGxlbmd0aCBjYW4gYmUgZXhwcmVzc2VkIGJ5IG9wZXJhdGluZyBvbiBhIHNsaWNlIG9mIHRoZVxuICogY29udGFpbmluZyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTcGFuXSAtIHRoZSBtYXhpbXVtIGxlbmd0aCBhbGxvd2VkIGZvciBlbmNvZGVkXG4gKiBzdHJpbmcgY29udGVudC4gIElmIG5vdCBwcm92aWRlZCB0aGVyZSBpcyBubyBib3VuZCBvbiB0aGUgYWxsb3dlZFxuICogY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVURjggZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihtYXhTcGFuLCBwcm9wZXJ0eSkge1xuICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBtYXhTcGFuKVxuICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgIHByb3BlcnR5ID0gbWF4U3BhbjtcbiAgICAgIG1heFNwYW4gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh1bmRlZmluZWQgPT09IG1heFNwYW4pIHtcbiAgICAgIG1heFNwYW4gPSAtMTtcbiAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFNwYW4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTcGFuIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIG1heGltdW0gc3BhbiBvZiB0aGUgbGF5b3V0IGluIGJ5dGVzLlxuICAgICAqXG4gICAgICogUG9zaXRpdmUgdmFsdWVzIGFyZSBnZW5lcmFsbHkgZXhwZWN0ZWQuICBaZXJvIGlzIGFibm9ybWFsLlxuICAgICAqIEF0dGVtcHRzIHRvIGVuY29kZSBvciBkZWNvZGUgYSB2YWx1ZSB0aGF0IGV4Y2VlZHMgdGhpcyBsZW5ndGhcbiAgICAgKiB3aWxsIHRocm93IGEgYFJhbmdlRXJyb3JgLlxuICAgICAqXG4gICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBubyBib3VuZCBvbiB0aGUgbGVuZ3RoXG4gICAgICogb2YgdGhlIGNvbnRlbnQuICovXG4gICAgdGhpcy5tYXhTcGFuID0gbWF4U3BhbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoIWJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2IgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBiLmxlbmd0aCAtIG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCwgZGVzdCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICBpZiAoKDAgPD0gdGhpcy5tYXhTcGFuKVxuICAgICAgICAmJiAodGhpcy5tYXhTcGFuIDwgc3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuKS50b1N0cmluZygndXRmLTgnKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAqIHNyYyAqL1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgc3JjID0gc3JjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHNyY2IgPSBuZXcgYnVmZmVyLkJ1ZmZlcihzcmMsICd1dGY4Jyk7XG4gICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICYmICh0aGlzLm1heFNwYW4gPCBzcGFuKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhbicpO1xuICAgIH1cbiAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICB9XG4gICAgc3JjYi5jb3B5KGIsIG9mZnNldCk7XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWluIGEgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogVGhpcyBsYXlvdXQgbWF5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBKYXZhU2NyaXB0IHZhbHVlIGNhbiBiZVxuICogaW5mZXJyZWQgd2l0aG91dCBhbiBleHByZXNzaW9uIGluIHRoZSBiaW5hcnkgZW5jb2RpbmcuICBBbiBleGFtcGxlXG4gKiB3b3VsZCBiZSBhIHtAbGluayBWYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0fSB3aGVyZSB0aGUgY29udGVudFxuICogaXMgaW1wbGllZCBieSB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gdmFsdWUgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBDb25zdGFudCN2YWx1ZXx2YWx1ZX0uICBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChvciBhcnJheSkgYW5kXG4gKiB0aGUgYXBwbGljYXRpb24gaW50ZW5kcyB0aGUgb2JqZWN0IHRvIHJlbWFpbiB1bmNoYW5nZWQgcmVnYXJkbGVzc1xuICogb2Ygd2hhdCBpcyBkb25lIHRvIHZhbHVlcyBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LCB0aGUgdmFsdWUgc2hvdWxkXG4gKiBiZSBmcm96ZW4gcHJpb3IgcGFzc2luZyBpdCB0byB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ29uc3RhbnQgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICBzdXBlcigwLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIHZhbHVlIHByb2R1Y2VkIGJ5IHRoaXMgY29uc3RhbnQgd2hlbiB0aGUgbGF5b3V0IGlzIHtAbGlua1xuICAgICAqIENvbnN0YW50I2RlY29kZXxkZWNvZGVkfS5cbiAgICAgKlxuICAgICAqIEFueSBKYXZhU2NyaXB0IHZhbHVlIGluY2x1ZGluZyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGlzXG4gICAgICogcGVybWl0dGVkLlxuICAgICAqXG4gICAgICogKipXQVJOSU5HKiogSWYgYHZhbHVlYCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdhcyBub3RcbiAgICAgKiBmcm96ZW4sIGl0IGlzIHBvc3NpYmxlIGZvciB1c2VycyBvZiBkZWNvZGVkIHZhbHVlcyB0byBjaGFuZ2VcbiAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgdmFsdWUuICovXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0LCBkZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIC8qIENvbnN0YW50cyB0YWtlIG5vIHNwYWNlICovXG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuTGF5b3V0JDEuRXh0ZXJuYWxMYXlvdXQgPSBFeHRlcm5hbExheW91dDtcbkxheW91dCQxLkdyZWVkeUNvdW50ID0gR3JlZWR5Q291bnQ7XG5MYXlvdXQkMS5PZmZzZXRMYXlvdXQgPSBPZmZzZXRMYXlvdXQ7XG5MYXlvdXQkMS5VSW50ID0gVUludDtcbkxheW91dCQxLlVJbnRCRSA9IFVJbnRCRTtcbkxheW91dCQxLkludCA9IEludDtcbkxheW91dCQxLkludEJFID0gSW50QkU7XG5MYXlvdXQkMS5GbG9hdCA9IEZsb2F0O1xuTGF5b3V0JDEuRmxvYXRCRSA9IEZsb2F0QkU7XG5MYXlvdXQkMS5Eb3VibGUgPSBEb3VibGU7XG5MYXlvdXQkMS5Eb3VibGVCRSA9IERvdWJsZUJFO1xuTGF5b3V0JDEuU2VxdWVuY2UgPSBTZXF1ZW5jZTtcbkxheW91dCQxLlN0cnVjdHVyZSA9IFN0cnVjdHVyZTtcbkxheW91dCQxLlVuaW9uRGlzY3JpbWluYXRvciA9IFVuaW9uRGlzY3JpbWluYXRvcjtcbkxheW91dCQxLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcjtcbkxheW91dCQxLlVuaW9uID0gVW5pb247XG5MYXlvdXQkMS5WYXJpYW50TGF5b3V0ID0gVmFyaWFudExheW91dDtcbkxheW91dCQxLkJpdFN0cnVjdHVyZSA9IEJpdFN0cnVjdHVyZTtcbkxheW91dCQxLkJpdEZpZWxkID0gQml0RmllbGQ7XG5MYXlvdXQkMS5Cb29sZWFuID0gQm9vbGVhbjtcbkxheW91dCQxLkJsb2IgPSBCbG9iO1xuTGF5b3V0JDEuQ1N0cmluZyA9IENTdHJpbmc7XG5MYXlvdXQkMS5VVEY4ID0gVVRGODtcbkxheW91dCQxLkNvbnN0YW50ID0gQ29uc3RhbnQ7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgR3JlZWR5Q291bnR9LiAqL1xuTGF5b3V0JDEuZ3JlZWR5ID0gKChlbGVtZW50U3BhbiwgcHJvcGVydHkpID0+IG5ldyBHcmVlZHlDb3VudChlbGVtZW50U3BhbiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBPZmZzZXRMYXlvdXR9LiAqL1xuTGF5b3V0JDEub2Zmc2V0ID0gKChsYXlvdXQsIG9mZnNldCwgcHJvcGVydHkpID0+IG5ldyBPZmZzZXRMYXlvdXQobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHx1bnNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xudmFyIHU4ID0gTGF5b3V0JDEudTggPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoMSwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5MYXlvdXQkMS51MTYgPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoMiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbkxheW91dCQxLnUyNCA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCgzLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG52YXIgdTMyID0gTGF5b3V0JDEudTMyID0gKHByb3BlcnR5ID0+IG5ldyBVSW50KDQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbkxheW91dCQxLnU0MCA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCg1LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbkxheW91dCQxLnU0OCA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCg2LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJVSW50NjR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5MYXlvdXQkMS5udTY0ID0gKHByb3BlcnR5ID0+IG5ldyBOZWFyVUludDY0KHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuTGF5b3V0JDEudTE2YmUgPSAocHJvcGVydHkgPT4gbmV3IFVJbnRCRSgyLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuTGF5b3V0JDEudTI0YmUgPSAocHJvcGVydHkgPT4gbmV3IFVJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5MYXlvdXQkMS51MzJiZSA9IChwcm9wZXJ0eSA9PiBuZXcgVUludEJFKDQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbkxheW91dCQxLnU0MGJlID0gKHByb3BlcnR5ID0+IG5ldyBVSW50QkUoNSwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5MYXlvdXQkMS51NDhiZSA9IChwcm9wZXJ0eSA9PiBuZXcgVUludEJFKDYsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NEJFfGJpZy1lbmRpYW4gdW5zaWduZWQgaW50XG4gKiBsYXlvdXRzfSBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuTGF5b3V0JDEubnU2NGJlID0gKHByb3BlcnR5ID0+IG5ldyBOZWFyVUludDY0QkUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8c2lnbmVkIGludCBsYXlvdXRzfSBzcGFubmluZyBvbmVcbiAqIGJ5dGUuICovXG5MYXlvdXQkMS5zOCA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDEsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuTGF5b3V0JDEuczE2ID0gKHByb3BlcnR5ID0+IG5ldyBJbnQoMiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbkxheW91dCQxLnMyNCA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDMsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbkxheW91dCQxLnMzMiA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbkxheW91dCQxLnM0MCA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDUsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuTGF5b3V0JDEuczQ4ID0gKHByb3BlcnR5ID0+IG5ldyBJbnQoNiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFySW50NjR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuTGF5b3V0JDEubnM2NCA9IChwcm9wZXJ0eSA9PiBuZXcgTmVhckludDY0KHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuTGF5b3V0JDEuczE2YmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDIsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5MYXlvdXQkMS5zMjRiZSA9IChwcm9wZXJ0eSA9PiBuZXcgSW50QkUoMywgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuTGF5b3V0JDEuczMyYmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbkxheW91dCQxLnM0MGJlID0gKHByb3BlcnR5ID0+IG5ldyBJbnRCRSg1LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbkxheW91dCQxLnM0OGJlID0gKHByb3BlcnR5ID0+IG5ldyBJbnRCRSg2LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJJbnQ2NEJFfGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbkxheW91dCQxLm5zNjRiZSA9IChwcm9wZXJ0eSA9PiBuZXcgTmVhckludDY0QkUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBGbG9hdHxsaXR0bGUtZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuTGF5b3V0JDEuZjMyID0gKHByb3BlcnR5ID0+IG5ldyBGbG9hdChwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEZsb2F0QkV8YmlnLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbkxheW91dCQxLmYzMmJlID0gKHByb3BlcnR5ID0+IG5ldyBGbG9hdEJFKHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRG91YmxlfGxpdHRsZS1lbmRpYW4gNjQtYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5MYXlvdXQkMS5mNjQgPSAocHJvcGVydHkgPT4gbmV3IERvdWJsZShwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZUJFfGJpZy1lbmRpYW4gNjQtYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5MYXlvdXQkMS5mNjRiZSA9IChwcm9wZXJ0eSA9PiBuZXcgRG91YmxlQkUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbnZhciBzdHJ1Y3QgPSBMYXlvdXQkMS5zdHJ1Y3QgPSAoKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSA9PiBuZXcgU3RydWN0dXJlKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQml0U3RydWN0dXJlfSB2YWx1ZXMuICovXG5MYXlvdXQkMS5iaXRzID0gKCh3b3JkLCBtc2IsIHByb3BlcnR5KSA9PiBuZXcgQml0U3RydWN0dXJlKHdvcmQsIG1zYiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTZXF1ZW5jZX0gdmFsdWVzLiAqL1xuTGF5b3V0JDEuc2VxID0gKChlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpID0+IG5ldyBTZXF1ZW5jZShlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVbmlvbn0gdmFsdWVzLiAqL1xuTGF5b3V0JDEudW5pb24gPSAoKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkgPT4gbmV3IFVuaW9uKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcn0gdmFsdWVzLiAqL1xuTGF5b3V0JDEudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gKChsYXlvdXQsIHByb3BlcnR5KSA9PiBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGxheW91dCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBCbG9ifSB2YWx1ZXMuICovXG52YXIgYmxvYiA9IExheW91dCQxLmJsb2IgPSAoKGxlbmd0aCwgcHJvcGVydHkpID0+IG5ldyBCbG9iKGxlbmd0aCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDU3RyaW5nfSB2YWx1ZXMuICovXG5MYXlvdXQkMS5jc3RyID0gKHByb3BlcnR5ID0+IG5ldyBDU3RyaW5nKHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVVRGOH0gdmFsdWVzLiAqL1xuTGF5b3V0JDEudXRmOCA9ICgobWF4U3BhbiwgcHJvcGVydHkpID0+IG5ldyBVVEY4KG1heFNwYW4sIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQ29uc3RhbnR9IHZhbHVlcy4gKi9cbkxheW91dCQxLmNvbnN0ID0gKCh2YWx1ZSwgcHJvcGVydHkpID0+IG5ldyBDb25zdGFudCh2YWx1ZSwgcHJvcGVydHkpKTtcblxuLy8gICAgICBcbi8qKlxuICogTGF5b3V0IGZvciBhIHB1YmxpYyBrZXlcbiAqL1xuXG5jb25zdCBwdWJsaWNLZXkgPSAocHJvcGVydHkgPSAncHVibGljS2V5JykgPT4ge1xuICByZXR1cm4gYmxvYigzMiwgcHJvcGVydHkpO1xufTtcbi8qKlxuICogTGF5b3V0IGZvciBhIDY0Yml0IHVuc2lnbmVkIHZhbHVlXG4gKi9cblxuY29uc3QgdWludDY0ID0gKHByb3BlcnR5ID0gJ3VpbnQ2NCcpID0+IHtcbiAgcmV0dXJuIGJsb2IoOCwgcHJvcGVydHkpO1xufTtcblxuLy8gICAgICBcbmZ1bmN0aW9uIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24odGl0bGUsIGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCAuLi5zaWduZXJzKSB7XG4gIHJldHVybiBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uJDEoY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIHNpZ25lcnMsIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZVxuICB9KTtcbn1cblxuY29uc3QgVE9LRU5fUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ1Rva2Vua2VnUWZlWnlpTndBSmJOYkdLUEZYQ1d1QnZmOVNzNjIzVlE1REEnKTtcbmNvbnN0IEFTU09DSUFURURfVE9LRU5fUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0FUb2tlbkdQdmJkR1Z4cjFiMmh2WmJzaXFXNXhXSDI1ZWZUTnNMSkE4a25MJyk7XG5jb25zdCBGQUlMRURfVE9fRklORF9BQ0NPVU5UID0gJ0ZhaWxlZCB0byBmaW5kIGFjY291bnQnO1xuY29uc3QgSU5WQUxJRF9BQ0NPVU5UX09XTkVSID0gJ0ludmFsaWQgYWNjb3VudCBvd25lcic7XG4vKipcbiAqIFVuZm9ydHVuYXRlbHksIEJ1ZmZlckxheW91dC5lbmNvZGUgdXNlcyBhbiBgaW5zdGFuY2VvZmAgY2hlY2sgZm9yIGBCdWZmZXJgXG4gKiB3aGljaCBmYWlscyB3aGVuIHVzaW5nIGBwdWJsaWNLZXkudG9CdWZmZXIoKWAgZGlyZWN0bHkgYmVjYXVzZSB0aGUgYnVuZGxlZCBgQnVmZmVyYFxuICogY2xhc3MgaW4gYEBzb2xhbmEvd2ViMy5qc2AgaXMgZGlmZmVyZW50IGZyb20gdGhlIGJ1bmRsZWQgYEJ1ZmZlcmAgY2xhc3MgaW4gdGhpcyBwYWNrYWdlXG4gKi9cblxuZnVuY3Rpb24gcHVia2V5VG9CdWZmZXIocHVibGljS2V5KSB7XG4gIHJldHVybiBidWZmZXIuQnVmZmVyLmZyb20ocHVibGljS2V5LnRvQnVmZmVyKCkpO1xufVxuLyoqXG4gKiA2NC1iaXQgdmFsdWVcbiAqL1xuXG5cbmNsYXNzIHU2NCBleHRlbmRzIEJOIHtcbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gQnVmZmVyIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICB0b0J1ZmZlcigpIHtcbiAgICBjb25zdCBhID0gc3VwZXIudG9BcnJheSgpLnJldmVyc2UoKTtcbiAgICBjb25zdCBiID0gYnVmZmVyLkJ1ZmZlci5mcm9tKGEpO1xuXG4gICAgaWYgKGIubGVuZ3RoID09PSA4KSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG5cbiAgICBhc3NlcnQoYi5sZW5ndGggPCA4LCAndTY0IHRvbyBsYXJnZScpO1xuICAgIGNvbnN0IHplcm9QYWQgPSBidWZmZXIuQnVmZmVyLmFsbG9jKDgpO1xuICAgIGIuY29weSh6ZXJvUGFkKTtcbiAgICByZXR1cm4gemVyb1BhZDtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgdTY0IGZyb20gQnVmZmVyIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgYXNzZXJ0KGJ1ZmZlci5sZW5ndGggPT09IDgsIGBJbnZhbGlkIGJ1ZmZlciBsZW5ndGg6ICR7YnVmZmVyLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gbmV3IHU2NChbLi4uYnVmZmVyXS5yZXZlcnNlKCkubWFwKGkgPT4gYDAwJHtpLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSkuam9pbignJyksIDE2KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQWNjb3VudChhY2NvdW50T3JQdWJsaWNLZXkpIHtcbiAgcmV0dXJuICdwdWJsaWNLZXknIGluIGFjY291bnRPclB1YmxpY0tleTtcbn1cblxuY29uc3QgQXV0aG9yaXR5VHlwZUNvZGVzID0ge1xuICBNaW50VG9rZW5zOiAwLFxuICBGcmVlemVBY2NvdW50OiAxLFxuICBBY2NvdW50T3duZXI6IDIsXG4gIENsb3NlQWNjb3VudDogM1xufTsgLy8gVGhlIGFkZHJlc3Mgb2YgdGhlIHNwZWNpYWwgbWludCBmb3Igd3JhcHBlZCBuYXRpdmUgdG9rZW4uXG5cbmNvbnN0IE5BVElWRV9NSU5UID0gbmV3IFB1YmxpY0tleSgnU28xMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMicpO1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgbWludFxuICovXG5cbmNvbnN0IE1pbnRMYXlvdXQgPSBzdHJ1Y3QoW3UzMignbWludEF1dGhvcml0eU9wdGlvbicpLCBwdWJsaWNLZXkoJ21pbnRBdXRob3JpdHknKSwgdWludDY0KCdzdXBwbHknKSwgdTgoJ2RlY2ltYWxzJyksIHU4KCdpc0luaXRpYWxpemVkJyksIHUzMignZnJlZXplQXV0aG9yaXR5T3B0aW9uJyksIHB1YmxpY0tleSgnZnJlZXplQXV0aG9yaXR5JyldKTtcbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgYW4gYWNjb3VudFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBBY2NvdW50TGF5b3V0ID0gc3RydWN0KFtwdWJsaWNLZXkoJ21pbnQnKSwgcHVibGljS2V5KCdvd25lcicpLCB1aW50NjQoJ2Ftb3VudCcpLCB1MzIoJ2RlbGVnYXRlT3B0aW9uJyksIHB1YmxpY0tleSgnZGVsZWdhdGUnKSwgdTgoJ3N0YXRlJyksIHUzMignaXNOYXRpdmVPcHRpb24nKSwgdWludDY0KCdpc05hdGl2ZScpLCB1aW50NjQoJ2RlbGVnYXRlZEFtb3VudCcpLCB1MzIoJ2Nsb3NlQXV0aG9yaXR5T3B0aW9uJyksIHB1YmxpY0tleSgnY2xvc2VBdXRob3JpdHknKV0pO1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhbiBtdWx0aXNpZ1xuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBNdWx0aXNpZ0xheW91dCA9IHN0cnVjdChbdTgoJ20nKSwgdTgoJ24nKSwgdTgoJ2lzX2luaXRpYWxpemVkJyksIHB1YmxpY0tleSgnc2lnbmVyMScpLCBwdWJsaWNLZXkoJ3NpZ25lcjInKSwgcHVibGljS2V5KCdzaWduZXIzJyksIHB1YmxpY0tleSgnc2lnbmVyNCcpLCBwdWJsaWNLZXkoJ3NpZ25lcjUnKSwgcHVibGljS2V5KCdzaWduZXI2JyksIHB1YmxpY0tleSgnc2lnbmVyNycpLCBwdWJsaWNLZXkoJ3NpZ25lcjgnKSwgcHVibGljS2V5KCdzaWduZXI5JyksIHB1YmxpY0tleSgnc2lnbmVyMTAnKSwgcHVibGljS2V5KCdzaWduZXIxMScpXSk7XG4vKipcbiAqIEFuIEVSQzIwLWxpa2UgVG9rZW5cbiAqL1xuXG5jbGFzcyBUb2tlbiB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgaWRlbnRpZnlpbmcgdGhpcyBtaW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBQcm9ncmFtIElkZW50aWZpZXIgZm9yIHRoZSBUb2tlbiBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBQcm9ncmFtIElkZW50aWZpZXIgZm9yIHRoZSBBc3NvY2lhdGVkIFRva2VuIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEZlZSBwYXllclxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVG9rZW4gb2JqZWN0IGF0dGFjaGVkIHRvIHRoZSBzcGVjaWZpYyBtaW50XG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gdG9rZW4gUHVibGljIGtleSBvZiB0aGUgbWludFxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIHRva2VuIHByb2dyYW1JZFxuICAgKiBAcGFyYW0gcGF5ZXIgUGF5ZXIgb2YgZmVlc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgcHVibGljS2V5LCBwcm9ncmFtSWQsIHBheWVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29ubmVjdGlvblwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHVibGljS2V5XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9ncmFtSWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzc29jaWF0ZWRQcm9ncmFtSWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBheWVyXCIsIHZvaWQgMCk7XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIGNvbm5lY3Rpb24sXG4gICAgICBwdWJsaWNLZXksXG4gICAgICBwcm9ncmFtSWQsXG4gICAgICBwYXllcixcbiAgICAgIC8vIEhhcmQgY29kZSBpcyBvazsgT3ZlcnJpZGluZyBpcyBuZWVkZWQgb25seSBmb3IgdGVzdHNcbiAgICAgIGFzc29jaWF0ZWRQcm9ncmFtSWQ6IEFTU09DSUFURURfVE9LRU5fUFJPR1JBTV9JRFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gYmFsYW5jZSBmb3IgdGhlIG1pbnQgdG8gYmUgcmVudCBleGVtcHRcbiAgICpcbiAgICogQHJldHVybiBOdW1iZXIgb2YgbGFtcG9ydHMgcmVxdWlyZWRcbiAgICovXG5cblxuICBzdGF0aWMgYXN5bmMgZ2V0TWluQmFsYW5jZVJlbnRGb3JFeGVtcHRNaW50KGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5nZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oTWludExheW91dC5zcGFuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIGJhbGFuY2UgZm9yIHRoZSBhY2NvdW50IHRvIGJlIHJlbnQgZXhlbXB0XG4gICAqXG4gICAqIEByZXR1cm4gTnVtYmVyIG9mIGxhbXBvcnRzIHJlcXVpcmVkXG4gICAqL1xuXG5cbiAgc3RhdGljIGFzeW5jIGdldE1pbkJhbGFuY2VSZW50Rm9yRXhlbXB0QWNjb3VudChjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rpb24uZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKEFjY291bnRMYXlvdXQuc3Bhbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSBiYWxhbmNlIGZvciB0aGUgbXVsdHNpZyB0byBiZSByZW50IGV4ZW1wdFxuICAgKlxuICAgKiBAcmV0dXJuIE51bWJlciBvZiBsYW1wb3J0cyByZXF1aXJlZFxuICAgKi9cblxuXG4gIHN0YXRpYyBhc3luYyBnZXRNaW5CYWxhbmNlUmVudEZvckV4ZW1wdE11bHRpc2lnKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5nZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oTXVsdGlzaWdMYXlvdXQuc3Bhbik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHBheWVyIEZlZSBwYXllciBmb3IgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIG1pbnRBdXRob3JpdHkgQWNjb3VudCBvciBtdWx0aXNpZyB0aGF0IHdpbGwgY29udHJvbCBtaW50aW5nXG4gICAqIEBwYXJhbSBmcmVlemVBdXRob3JpdHkgT3B0aW9uYWwgYWNjb3VudCBvciBtdWx0aXNpZyB0aGF0IGNhbiBmcmVlemUgdG9rZW4gYWNjb3VudHNcbiAgICogQHBhcmFtIGRlY2ltYWxzIExvY2F0aW9uIG9mIHRoZSBkZWNpbWFsIHBsYWNlXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgT3B0aW9uYWwgdG9rZW4gcHJvZ3JhbUlkLCB1c2VzIHRoZSBzeXN0ZW0gcHJvZ3JhbUlkIGJ5IGRlZmF1bHRcbiAgICogQHJldHVybiBUb2tlbiBvYmplY3QgZm9yIHRoZSBuZXdseSBtaW50ZWQgdG9rZW5cbiAgICovXG5cblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlTWludChjb25uZWN0aW9uLCBwYXllciwgbWludEF1dGhvcml0eSwgZnJlZXplQXV0aG9yaXR5LCBkZWNpbWFscywgcHJvZ3JhbUlkKSB7XG4gICAgY29uc3QgbWludEFjY291bnQgPSBLZXlwYWlyLmdlbmVyYXRlKCk7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgVG9rZW4oY29ubmVjdGlvbiwgbWludEFjY291bnQucHVibGljS2V5LCBwcm9ncmFtSWQsIHBheWVyKTsgLy8gQWxsb2NhdGUgbWVtb3J5IGZvciB0aGUgYWNjb3VudFxuXG4gICAgY29uc3QgYmFsYW5jZU5lZWRlZCA9IGF3YWl0IFRva2VuLmdldE1pbkJhbGFuY2VSZW50Rm9yRXhlbXB0TWludChjb25uZWN0aW9uKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogbWludEFjY291bnQucHVibGljS2V5LFxuICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQsXG4gICAgICBzcGFjZTogTWludExheW91dC5zcGFuLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChUb2tlbi5jcmVhdGVJbml0TWludEluc3RydWN0aW9uKHByb2dyYW1JZCwgbWludEFjY291bnQucHVibGljS2V5LCBkZWNpbWFscywgbWludEF1dGhvcml0eSwgZnJlZXplQXV0aG9yaXR5KSk7IC8vIFNlbmQgdGhlIHR3byBpbnN0cnVjdGlvbnNcblxuICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oJ2NyZWF0ZUFjY291bnQgYW5kIEluaXRpYWxpemVNaW50JywgY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIHBheWVyLCBtaW50QWNjb3VudCk7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGluaXRpYWxpemUgYSBuZXcgYWNjb3VudC5cbiAgICpcbiAgICogVGhpcyBhY2NvdW50IG1heSB0aGVuIGJlIHVzZWQgYXMgYSBgdHJhbnNmZXIoKWAgb3IgYGFwcHJvdmUoKWAgZGVzdGluYXRpb25cbiAgICpcbiAgICogQHBhcmFtIG93bmVyIFVzZXIgYWNjb3VudCB0aGF0IHdpbGwgb3duIHRoZSBuZXcgYWNjb3VudFxuICAgKiBAcmV0dXJuIFB1YmxpYyBrZXkgb2YgdGhlIG5ldyBlbXB0eSBhY2NvdW50XG4gICAqL1xuXG5cbiAgYXN5bmMgY3JlYXRlQWNjb3VudChvd25lcikge1xuICAgIC8vIEFsbG9jYXRlIG1lbW9yeSBmb3IgdGhlIGFjY291bnRcbiAgICBjb25zdCBiYWxhbmNlTmVlZGVkID0gYXdhaXQgVG9rZW4uZ2V0TWluQmFsYW5jZVJlbnRGb3JFeGVtcHRBY2NvdW50KHRoaXMuY29ubmVjdGlvbik7XG4gICAgY29uc3QgbmV3QWNjb3VudCA9IEtleXBhaXIuZ2VuZXJhdGUoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogdGhpcy5wYXllci5wdWJsaWNLZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBuZXdBY2NvdW50LnB1YmxpY0tleSxcbiAgICAgIGxhbXBvcnRzOiBiYWxhbmNlTmVlZGVkLFxuICAgICAgc3BhY2U6IEFjY291bnRMYXlvdXQuc3BhbixcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgY29uc3QgbWludFB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgIHRyYW5zYWN0aW9uLmFkZChUb2tlbi5jcmVhdGVJbml0QWNjb3VudEluc3RydWN0aW9uKHRoaXMucHJvZ3JhbUlkLCBtaW50UHVibGljS2V5LCBuZXdBY2NvdW50LnB1YmxpY0tleSwgb3duZXIpKTsgLy8gU2VuZCB0aGUgdHdvIGluc3RydWN0aW9uc1xuXG4gICAgYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbignY3JlYXRlQWNjb3VudCBhbmQgSW5pdGlhbGl6ZUFjY291bnQnLCB0aGlzLmNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCB0aGlzLnBheWVyLCBuZXdBY2NvdW50KTtcbiAgICByZXR1cm4gbmV3QWNjb3VudC5wdWJsaWNLZXk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgaW5pdGlhbGl6ZSB0aGUgYXNzb2NpYXRlZCBhY2NvdW50LlxuICAgKlxuICAgKiBUaGlzIGFjY291bnQgbWF5IHRoZW4gYmUgdXNlZCBhcyBhIGB0cmFuc2ZlcigpYCBvciBgYXBwcm92ZSgpYCBkZXN0aW5hdGlvblxuICAgKlxuICAgKiBAcGFyYW0gb3duZXIgVXNlciBhY2NvdW50IHRoYXQgd2lsbCBvd24gdGhlIG5ldyBhY2NvdW50XG4gICAqIEByZXR1cm4gUHVibGljIGtleSBvZiB0aGUgbmV3IGFzc29jaWF0ZWQgYWNjb3VudFxuICAgKi9cblxuXG4gIGFzeW5jIGNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQob3duZXIpIHtcbiAgICBjb25zdCBhc3NvY2lhdGVkQWRkcmVzcyA9IGF3YWl0IFRva2VuLmdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3ModGhpcy5hc3NvY2lhdGVkUHJvZ3JhbUlkLCB0aGlzLnByb2dyYW1JZCwgdGhpcy5wdWJsaWNLZXksIG93bmVyKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50SW50ZXJuYWwob3duZXIsIGFzc29jaWF0ZWRBZGRyZXNzKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRJbnRlcm5hbChvd25lciwgYXNzb2NpYXRlZEFkZHJlc3MpIHtcbiAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCdDcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50JywgdGhpcy5jb25uZWN0aW9uLCBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoVG9rZW4uY3JlYXRlQXNzb2NpYXRlZFRva2VuQWNjb3VudEluc3RydWN0aW9uKHRoaXMuYXNzb2NpYXRlZFByb2dyYW1JZCwgdGhpcy5wcm9ncmFtSWQsIHRoaXMucHVibGljS2V5LCBhc3NvY2lhdGVkQWRkcmVzcywgb3duZXIsIHRoaXMucGF5ZXIucHVibGljS2V5KSksIHRoaXMucGF5ZXIpO1xuICAgIHJldHVybiBhc3NvY2lhdGVkQWRkcmVzcztcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGFzc29jaWF0ZWQgYWNjb3VudCBvciBjcmVhdGUgb25lIGlmIG5vdCBmb3VuZC5cbiAgICpcbiAgICogVGhpcyBhY2NvdW50IG1heSB0aGVuIGJlIHVzZWQgYXMgYSBgdHJhbnNmZXIoKWAgb3IgYGFwcHJvdmUoKWAgZGVzdGluYXRpb25cbiAgICpcbiAgICogQHBhcmFtIG93bmVyIFVzZXIgYWNjb3VudCB0aGF0IHdpbGwgb3duIHRoZSBuZXcgYWNjb3VudFxuICAgKiBAcmV0dXJuIFRoZSBuZXcgYXNzb2NpYXRlZCBhY2NvdW50XG4gICAqL1xuXG5cbiAgYXN5bmMgZ2V0T3JDcmVhdGVBc3NvY2lhdGVkQWNjb3VudEluZm8ob3duZXIpIHtcbiAgICBjb25zdCBhc3NvY2lhdGVkQWRkcmVzcyA9IGF3YWl0IFRva2VuLmdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3ModGhpcy5hc3NvY2lhdGVkUHJvZ3JhbUlkLCB0aGlzLnByb2dyYW1JZCwgdGhpcy5wdWJsaWNLZXksIG93bmVyKTsgLy8gVGhpcyBpcyB0aGUgb3B0aW11bSBsb2dpYywgY29uc2lkZXJpbmcgVFggZmVlLCBjbGllbnQtc2lkZSBjb21wdXRhdGlvbixcbiAgICAvLyBSUEMgcm91bmR0cmlwcyBhbmQgZ3VhcmFudGVlZCBpZGVtcG90ZW50LlxuICAgIC8vIFNhZGx5IHdlIGNhbid0IGRvIHRoaXMgYXRvbWljYWxseTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mbyhhc3NvY2lhdGVkQWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJTlZBTElEX0FDQ09VTlRfT1dORVIgY2FuIGJlIHBvc3NpYmxlIGlmIHRoZSBhc3NvY2lhdGVkQWRkcmVzcyBoYXNcbiAgICAgIC8vIGFscmVhZHkgYmVlbiByZWNlaXZlZCBzb21lIGxhbXBvcnRzICg9IGJlY2FtZSBzeXN0ZW0gYWNjb3VudHMpLlxuICAgICAgLy8gQXNzdW1pbmcgcHJvZ3JhbSBkZXJpdmVkIGFkZHJlc3NpbmcgaXMgc2FmZSwgdGhpcyBpcyB0aGUgb25seSBjYXNlXG4gICAgICAvLyBmb3IgdGhlIElOVkFMSURfQUNDT1VOVF9PV05FUiBpbiB0aGlzIGNvZGUtcGF0aFxuICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBGQUlMRURfVE9fRklORF9BQ0NPVU5UIHx8IGVyci5tZXNzYWdlID09PSBJTlZBTElEX0FDQ09VTlRfT1dORVIpIHtcbiAgICAgICAgLy8gYXMgdGhpcyBpc24ndCBhdG9taWMsIGl0J3MgcG9zc2libGUgb3RoZXJzIGNhbiBjcmVhdGUgYXNzb2NpYXRlZFxuICAgICAgICAvLyBhY2NvdW50cyBtZWFud2hpbGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRJbnRlcm5hbChvd25lciwgYXNzb2NpYXRlZEFkZHJlc3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHsvLyBpZ25vcmUgYWxsIGVycm9yczsgZm9yIG5vdyB0aGVyZSBpcyBubyBBUEkgY29tcGF0aWJsZSB3YXkgdG9cbiAgICAgICAgICAvLyBzZWxlY3RpdmVseSBpZ25vcmUgdGhlIGV4cGVjdGVkIGluc3RydWN0aW9uIGVycm9yIGlmIHRoZVxuICAgICAgICAgIC8vIGFzc29jaWF0ZWQgYWNjb3VudCBpcyBleGlzdGluZyBhbHJlYWR5LlxuICAgICAgICB9IC8vIE5vdyB0aGlzIHNob3VsZCBhbHdheXMgc3VjY2VlZFxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm8oYXNzb2NpYXRlZEFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBpbml0aWFsaXplIGEgbmV3IGFjY291bnQgb24gdGhlIHNwZWNpYWwgbmF0aXZlIHRva2VuIG1pbnQuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIGJlIHdyYXBwZWQsIHRoZSBhY2NvdW50IG11c3QgaGF2ZSBhIGJhbGFuY2Ugb2YgbmF0aXZlIHRva2Vuc1xuICAgKiB3aGVuIGl0IGlzIGluaXRpYWxpemVkIHdpdGggdGhlIHRva2VuIHByb2dyYW0uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2VuZHMgbGFtcG9ydHMgdG8gdGhlIG5ldyBhY2NvdW50IGJlZm9yZSBpbml0aWFsaXppbmcgaXQuXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIEEgc29sYW5hIHdlYjMgY29ubmVjdGlvblxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFRoZSB0b2tlbiBwcm9ncmFtIElEXG4gICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgb2YgdGhlIG5ldyB0b2tlbiBhY2NvdW50XG4gICAqIEBwYXJhbSBwYXllciBUaGUgc291cmNlIG9mIHRoZSBsYW1wb3J0cyB0byBpbml0aWFsaXplLCBhbmQgcGF5ZXIgb2YgdGhlIGluaXRpYWxpemF0aW9uIGZlZXMuXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCBvZiBsYW1wb3J0cyB0byB3cmFwXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UHVibGljS2V5Pn0gVGhlIG5ldyB0b2tlbiBhY2NvdW50XG4gICAqL1xuXG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVdyYXBwZWROYXRpdmVBY2NvdW50KGNvbm5lY3Rpb24sIHByb2dyYW1JZCwgb3duZXIsIHBheWVyLCBhbW91bnQpIHtcbiAgICAvLyBBbGxvY2F0ZSBtZW1vcnkgZm9yIHRoZSBhY2NvdW50XG4gICAgY29uc3QgYmFsYW5jZU5lZWRlZCA9IGF3YWl0IFRva2VuLmdldE1pbkJhbGFuY2VSZW50Rm9yRXhlbXB0QWNjb3VudChjb25uZWN0aW9uKTsgLy8gQ3JlYXRlIGEgbmV3IGFjY291bnRcblxuICAgIGNvbnN0IG5ld0FjY291bnQgPSBLZXlwYWlyLmdlbmVyYXRlKCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IG5ld0FjY291bnQucHVibGljS2V5LFxuICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQsXG4gICAgICBzcGFjZTogQWNjb3VudExheW91dC5zcGFuLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSkpOyAvLyBTZW5kIGxhbXBvcnRzIHRvIGl0ICh0aGVzZSB3aWxsIGJlIHdyYXBwZWQgaW50byBuYXRpdmUgdG9rZW5zIGJ5IHRoZSB0b2tlbiBwcm9ncmFtKVxuXG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgdG9QdWJrZXk6IG5ld0FjY291bnQucHVibGljS2V5LFxuICAgICAgbGFtcG9ydHM6IGFtb3VudFxuICAgIH0pKTsgLy8gQXNzaWduIHRoZSBuZXcgYWNjb3VudCB0byB0aGUgbmF0aXZlIHRva2VuIG1pbnQuXG4gICAgLy8gdGhlIGFjY291bnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGEgYmFsYW5jZSBlcXVhbCB0byB0aGUgbmF0aXZlIHRva2VuIGJhbGFuY2UuXG4gICAgLy8gKGkuZS4gYW1vdW50KVxuXG4gICAgdHJhbnNhY3Rpb24uYWRkKFRva2VuLmNyZWF0ZUluaXRBY2NvdW50SW5zdHJ1Y3Rpb24ocHJvZ3JhbUlkLCBOQVRJVkVfTUlOVCwgbmV3QWNjb3VudC5wdWJsaWNLZXksIG93bmVyKSk7IC8vIFNlbmQgdGhlIHRocmVlIGluc3RydWN0aW9uc1xuXG4gICAgYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbignY3JlYXRlQWNjb3VudCwgdHJhbnNmZXIsIGFuZCBpbml0aWFsaXplQWNjb3VudCcsIGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBwYXllciwgbmV3QWNjb3VudCk7XG4gICAgcmV0dXJuIG5ld0FjY291bnQucHVibGljS2V5O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGluaXRpYWxpemUgYSBuZXcgbXVsdGlzaWcuXG4gICAqXG4gICAqIFRoaXMgYWNjb3VudCBtYXkgdGhlbiBiZSB1c2VkIGZvciBtdWx0aXNpZ25hdHVyZSB2ZXJpZmljYXRpb25cbiAgICpcbiAgICogQHBhcmFtIG0gTnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXNcbiAgICogQHBhcmFtIHNpZ25lcnMgRnVsbCBzZXQgb2Ygc2lnbmVyc1xuICAgKiBAcmV0dXJuIFB1YmxpYyBrZXkgb2YgdGhlIG5ldyBtdWx0aXNpZyBhY2NvdW50XG4gICAqL1xuXG5cbiAgYXN5bmMgY3JlYXRlTXVsdGlzaWcobSwgc2lnbmVycykge1xuICAgIGNvbnN0IG11bHRpc2lnQWNjb3VudCA9IEtleXBhaXIuZ2VuZXJhdGUoKTsgLy8gQWxsb2NhdGUgbWVtb3J5IGZvciB0aGUgYWNjb3VudFxuXG4gICAgY29uc3QgYmFsYW5jZU5lZWRlZCA9IGF3YWl0IFRva2VuLmdldE1pbkJhbGFuY2VSZW50Rm9yRXhlbXB0TXVsdGlzaWcodGhpcy5jb25uZWN0aW9uKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogdGhpcy5wYXllci5wdWJsaWNLZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBtdWx0aXNpZ0FjY291bnQucHVibGljS2V5LFxuICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQsXG4gICAgICBzcGFjZTogTXVsdGlzaWdMYXlvdXQuc3BhbixcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7IC8vIGNyZWF0ZSB0aGUgbmV3IGFjY291bnRcblxuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogbXVsdGlzaWdBY2NvdW50LnB1YmxpY0tleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgc2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiBrZXlzLnB1c2goe1xuICAgICAgcHVia2V5OiBzaWduZXIsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0pKTtcbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gc3RydWN0KFt1OCgnaW5zdHJ1Y3Rpb24nKSwgdTgoJ20nKV0pO1xuICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgaW5zdHJ1Y3Rpb246IDIsXG4gICAgICAvLyBJbml0aWFsaXplTXVsdGlzaWcgaW5zdHJ1Y3Rpb25cbiAgICAgIG1cbiAgICB9LCBkYXRhKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7IC8vIFNlbmQgdGhlIHR3byBpbnN0cnVjdGlvbnNcblxuICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oJ2NyZWF0ZUFjY291bnQgYW5kIEluaXRpYWxpemVNdWx0aXNpZycsIHRoaXMuY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIHRoaXMucGF5ZXIsIG11bHRpc2lnQWNjb3VudCk7XG4gICAgcmV0dXJuIG11bHRpc2lnQWNjb3VudC5wdWJsaWNLZXk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIG1pbnQgaW5mb3JtYXRpb25cbiAgICovXG5cblxuICBhc3luYyBnZXRNaW50SW5mbygpIHtcbiAgICBjb25zdCBpbmZvID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHRoaXMucHVibGljS2V5KTtcblxuICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIG1pbnQgYWNjb3VudCcpO1xuICAgIH1cblxuICAgIGlmICghaW5mby5vd25lci5lcXVhbHModGhpcy5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWludCBvd25lcjogJHtKU09OLnN0cmluZ2lmeShpbmZvLm93bmVyKX1gKTtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kYXRhLmxlbmd0aCAhPSBNaW50TGF5b3V0LnNwYW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtaW50IHNpemVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5mcm9tKGluZm8uZGF0YSk7XG4gICAgY29uc3QgbWludEluZm8gPSBNaW50TGF5b3V0LmRlY29kZShkYXRhKTtcblxuICAgIGlmIChtaW50SW5mby5taW50QXV0aG9yaXR5T3B0aW9uID09PSAwKSB7XG4gICAgICBtaW50SW5mby5taW50QXV0aG9yaXR5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWludEluZm8ubWludEF1dGhvcml0eSA9IG5ldyBQdWJsaWNLZXkobWludEluZm8ubWludEF1dGhvcml0eSk7XG4gICAgfVxuXG4gICAgbWludEluZm8uc3VwcGx5ID0gdTY0LmZyb21CdWZmZXIobWludEluZm8uc3VwcGx5KTtcbiAgICBtaW50SW5mby5pc0luaXRpYWxpemVkID0gbWludEluZm8uaXNJbml0aWFsaXplZCAhPSAwO1xuXG4gICAgaWYgKG1pbnRJbmZvLmZyZWV6ZUF1dGhvcml0eU9wdGlvbiA9PT0gMCkge1xuICAgICAgbWludEluZm8uZnJlZXplQXV0aG9yaXR5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWludEluZm8uZnJlZXplQXV0aG9yaXR5ID0gbmV3IFB1YmxpY0tleShtaW50SW5mby5mcmVlemVBdXRob3JpdHkpO1xuICAgIH1cblxuICAgIHJldHVybiBtaW50SW5mbztcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50XG4gICAqL1xuXG5cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm8oYWNjb3VudCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8oYWNjb3VudCwgY29tbWl0bWVudCk7XG5cbiAgICBpZiAoaW5mbyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEZBSUxFRF9UT19GSU5EX0FDQ09VTlQpO1xuICAgIH1cblxuICAgIGlmICghaW5mby5vd25lci5lcXVhbHModGhpcy5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9BQ0NPVU5UX09XTkVSKTtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kYXRhLmxlbmd0aCAhPSBBY2NvdW50TGF5b3V0LnNwYW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhY2NvdW50IHNpemVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5mcm9tKGluZm8uZGF0YSk7XG4gICAgY29uc3QgYWNjb3VudEluZm8gPSBBY2NvdW50TGF5b3V0LmRlY29kZShkYXRhKTtcbiAgICBhY2NvdW50SW5mby5hZGRyZXNzID0gYWNjb3VudDtcbiAgICBhY2NvdW50SW5mby5taW50ID0gbmV3IFB1YmxpY0tleShhY2NvdW50SW5mby5taW50KTtcbiAgICBhY2NvdW50SW5mby5vd25lciA9IG5ldyBQdWJsaWNLZXkoYWNjb3VudEluZm8ub3duZXIpO1xuICAgIGFjY291bnRJbmZvLmFtb3VudCA9IHU2NC5mcm9tQnVmZmVyKGFjY291bnRJbmZvLmFtb3VudCk7XG5cbiAgICBpZiAoYWNjb3VudEluZm8uZGVsZWdhdGVPcHRpb24gPT09IDApIHtcbiAgICAgIGFjY291bnRJbmZvLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIGFjY291bnRJbmZvLmRlbGVnYXRlZEFtb3VudCA9IG5ldyB1NjQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjb3VudEluZm8uZGVsZWdhdGUgPSBuZXcgUHVibGljS2V5KGFjY291bnRJbmZvLmRlbGVnYXRlKTtcbiAgICAgIGFjY291bnRJbmZvLmRlbGVnYXRlZEFtb3VudCA9IHU2NC5mcm9tQnVmZmVyKGFjY291bnRJbmZvLmRlbGVnYXRlZEFtb3VudCk7XG4gICAgfVxuXG4gICAgYWNjb3VudEluZm8uaXNJbml0aWFsaXplZCA9IGFjY291bnRJbmZvLnN0YXRlICE9PSAwO1xuICAgIGFjY291bnRJbmZvLmlzRnJvemVuID0gYWNjb3VudEluZm8uc3RhdGUgPT09IDI7XG5cbiAgICBpZiAoYWNjb3VudEluZm8uaXNOYXRpdmVPcHRpb24gPT09IDEpIHtcbiAgICAgIGFjY291bnRJbmZvLnJlbnRFeGVtcHRSZXNlcnZlID0gdTY0LmZyb21CdWZmZXIoYWNjb3VudEluZm8uaXNOYXRpdmUpO1xuICAgICAgYWNjb3VudEluZm8uaXNOYXRpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NvdW50SW5mby5yZW50RXhlbXB0UmVzZXJ2ZSA9IG51bGw7XG4gICAgICBhY2NvdW50SW5mby5pc05hdGl2ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhY2NvdW50SW5mby5jbG9zZUF1dGhvcml0eU9wdGlvbiA9PT0gMCkge1xuICAgICAgYWNjb3VudEluZm8uY2xvc2VBdXRob3JpdHkgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NvdW50SW5mby5jbG9zZUF1dGhvcml0eSA9IG5ldyBQdWJsaWNLZXkoYWNjb3VudEluZm8uY2xvc2VBdXRob3JpdHkpO1xuICAgIH1cblxuICAgIGlmICghYWNjb3VudEluZm8ubWludC5lcXVhbHModGhpcy5wdWJsaWNLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWNjb3VudCBtaW50OiAke0pTT04uc3RyaW5naWZ5KGFjY291bnRJbmZvLm1pbnQpfSAhPT0gJHtKU09OLnN0cmluZ2lmeSh0aGlzLnB1YmxpY0tleSl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY291bnRJbmZvO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBNdWx0aXNpZyBpbmZvcm1hdGlvblxuICAgKlxuICAgKiBAcGFyYW0gbXVsdGlzaWcgUHVibGljIGtleSBvZiB0aGUgYWNjb3VudFxuICAgKi9cblxuXG4gIGFzeW5jIGdldE11bHRpc2lnSW5mbyhtdWx0aXNpZykge1xuICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8obXVsdGlzaWcpO1xuXG4gICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgbXVsdGlzaWcnKTtcbiAgICB9XG5cbiAgICBpZiAoIWluZm8ub3duZXIuZXF1YWxzKHRoaXMucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG11bHRpc2lnIG93bmVyYCk7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZGF0YS5sZW5ndGggIT0gTXVsdGlzaWdMYXlvdXQuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG11bHRpc2lnIHNpemVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5mcm9tKGluZm8uZGF0YSk7XG4gICAgY29uc3QgbXVsdGlzaWdJbmZvID0gTXVsdGlzaWdMYXlvdXQuZGVjb2RlKGRhdGEpO1xuICAgIG11bHRpc2lnSW5mby5zaWduZXIxID0gbmV3IFB1YmxpY0tleShtdWx0aXNpZ0luZm8uc2lnbmVyMSk7XG4gICAgbXVsdGlzaWdJbmZvLnNpZ25lcjIgPSBuZXcgUHVibGljS2V5KG11bHRpc2lnSW5mby5zaWduZXIyKTtcbiAgICBtdWx0aXNpZ0luZm8uc2lnbmVyMyA9IG5ldyBQdWJsaWNLZXkobXVsdGlzaWdJbmZvLnNpZ25lcjMpO1xuICAgIG11bHRpc2lnSW5mby5zaWduZXI0ID0gbmV3IFB1YmxpY0tleShtdWx0aXNpZ0luZm8uc2lnbmVyNCk7XG4gICAgbXVsdGlzaWdJbmZvLnNpZ25lcjUgPSBuZXcgUHVibGljS2V5KG11bHRpc2lnSW5mby5zaWduZXI1KTtcbiAgICBtdWx0aXNpZ0luZm8uc2lnbmVyNiA9IG5ldyBQdWJsaWNLZXkobXVsdGlzaWdJbmZvLnNpZ25lcjYpO1xuICAgIG11bHRpc2lnSW5mby5zaWduZXI3ID0gbmV3IFB1YmxpY0tleShtdWx0aXNpZ0luZm8uc2lnbmVyNyk7XG4gICAgbXVsdGlzaWdJbmZvLnNpZ25lcjggPSBuZXcgUHVibGljS2V5KG11bHRpc2lnSW5mby5zaWduZXI4KTtcbiAgICBtdWx0aXNpZ0luZm8uc2lnbmVyOSA9IG5ldyBQdWJsaWNLZXkobXVsdGlzaWdJbmZvLnNpZ25lcjkpO1xuICAgIG11bHRpc2lnSW5mby5zaWduZXIxMCA9IG5ldyBQdWJsaWNLZXkobXVsdGlzaWdJbmZvLnNpZ25lcjEwKTtcbiAgICBtdWx0aXNpZ0luZm8uc2lnbmVyMTEgPSBuZXcgUHVibGljS2V5KG11bHRpc2lnSW5mby5zaWduZXIxMSk7XG4gICAgcmV0dXJuIG11bHRpc2lnSW5mbztcbiAgfVxuICAvKipcbiAgICogVHJhbnNmZXIgdG9rZW5zIHRvIGFub3RoZXIgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIFNvdXJjZSBhY2NvdW50XG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBhY2NvdW50XG4gICAqIEBwYXJhbSBvd25lciBPd25lciBvZiB0aGUgc291cmNlIGFjY291bnRcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBvd25lcmAgaXMgYSBtdWx0aVNpZ1xuICAgKiBAcGFyYW0gYW1vdW50IE51bWJlciBvZiB0b2tlbnMgdG8gdHJhbnNmZXJcbiAgICovXG5cblxuICBhc3luYyB0cmFuc2Zlcihzb3VyY2UsIGRlc3RpbmF0aW9uLCBvd25lciwgbXVsdGlTaWduZXJzLCBhbW91bnQpIHtcbiAgICBsZXQgb3duZXJQdWJsaWNLZXk7XG4gICAgbGV0IHNpZ25lcnM7XG5cbiAgICBpZiAoaXNBY2NvdW50KG93bmVyKSkge1xuICAgICAgb3duZXJQdWJsaWNLZXkgPSBvd25lci5wdWJsaWNLZXk7XG4gICAgICBzaWduZXJzID0gW293bmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duZXJQdWJsaWNLZXkgPSBvd25lcjtcbiAgICAgIHNpZ25lcnMgPSBtdWx0aVNpZ25lcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oJ1RyYW5zZmVyJywgdGhpcy5jb25uZWN0aW9uLCBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoVG9rZW4uY3JlYXRlVHJhbnNmZXJJbnN0cnVjdGlvbih0aGlzLnByb2dyYW1JZCwgc291cmNlLCBkZXN0aW5hdGlvbiwgb3duZXJQdWJsaWNLZXksIG11bHRpU2lnbmVycywgYW1vdW50KSksIHRoaXMucGF5ZXIsIC4uLnNpZ25lcnMpO1xuICB9XG4gIC8qKlxuICAgKiBHcmFudCBhIHRoaXJkLXBhcnR5IHBlcm1pc3Npb24gdG8gdHJhbnNmZXIgdXAgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdG9rZW5zIGZyb20gYW4gYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50XG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSBBY2NvdW50IGF1dGhvcml6ZWQgdG8gcGVyZm9ybSBhIHRyYW5zZmVyIHRva2VucyBmcm9tIHRoZSBzb3VyY2UgYWNjb3VudFxuICAgKiBAcGFyYW0gb3duZXIgT3duZXIgb2YgdGhlIHNvdXJjZSBhY2NvdW50XG4gICAqIEBwYXJhbSBtdWx0aVNpZ25lcnMgU2lnbmluZyBhY2NvdW50cyBpZiBgb3duZXJgIGlzIGEgbXVsdGlTaWdcbiAgICogQHBhcmFtIGFtb3VudCBNYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgdGhlIGRlbGVnYXRlIG1heSB0cmFuc2ZlclxuICAgKi9cblxuXG4gIGFzeW5jIGFwcHJvdmUoYWNjb3VudCwgZGVsZWdhdGUsIG93bmVyLCBtdWx0aVNpZ25lcnMsIGFtb3VudCkge1xuICAgIGxldCBvd25lclB1YmxpY0tleTtcbiAgICBsZXQgc2lnbmVycztcblxuICAgIGlmIChpc0FjY291bnQob3duZXIpKSB7XG4gICAgICBvd25lclB1YmxpY0tleSA9IG93bmVyLnB1YmxpY0tleTtcbiAgICAgIHNpZ25lcnMgPSBbb3duZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25lclB1YmxpY0tleSA9IG93bmVyO1xuICAgICAgc2lnbmVycyA9IG11bHRpU2lnbmVycztcbiAgICB9XG5cbiAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCdBcHByb3ZlJywgdGhpcy5jb25uZWN0aW9uLCBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoVG9rZW4uY3JlYXRlQXBwcm92ZUluc3RydWN0aW9uKHRoaXMucHJvZ3JhbUlkLCBhY2NvdW50LCBkZWxlZ2F0ZSwgb3duZXJQdWJsaWNLZXksIG11bHRpU2lnbmVycywgYW1vdW50KSksIHRoaXMucGF5ZXIsIC4uLnNpZ25lcnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYXBwcm92YWwgZm9yIHRoZSB0cmFuc2ZlciBvZiBhbnkgcmVtYWluaW5nIHRva2Vuc1xuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50XG4gICAqIEBwYXJhbSBvd25lciBPd25lciBvZiB0aGUgc291cmNlIGFjY291bnRcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBvd25lcmAgaXMgYSBtdWx0aVNpZ1xuICAgKi9cblxuXG4gIGFzeW5jIHJldm9rZShhY2NvdW50LCBvd25lciwgbXVsdGlTaWduZXJzKSB7XG4gICAgbGV0IG93bmVyUHVibGljS2V5O1xuICAgIGxldCBzaWduZXJzO1xuXG4gICAgaWYgKGlzQWNjb3VudChvd25lcikpIHtcbiAgICAgIG93bmVyUHVibGljS2V5ID0gb3duZXIucHVibGljS2V5O1xuICAgICAgc2lnbmVycyA9IFtvd25lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bmVyUHVibGljS2V5ID0gb3duZXI7XG4gICAgICBzaWduZXJzID0gbXVsdGlTaWduZXJzO1xuICAgIH1cblxuICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oJ1Jldm9rZScsIHRoaXMuY29ubmVjdGlvbiwgbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFRva2VuLmNyZWF0ZVJldm9rZUluc3RydWN0aW9uKHRoaXMucHJvZ3JhbUlkLCBhY2NvdW50LCBvd25lclB1YmxpY0tleSwgbXVsdGlTaWduZXJzKSksIHRoaXMucGF5ZXIsIC4uLnNpZ25lcnMpO1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ24gYSBuZXcgYXV0aG9yaXR5IHRvIHRoZSBhY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBhY2NvdW50IFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnRcbiAgICogQHBhcmFtIG5ld0F1dGhvcml0eSBOZXcgYXV0aG9yaXR5IG9mIHRoZSBhY2NvdW50XG4gICAqIEBwYXJhbSBhdXRob3JpdHlUeXBlIFR5cGUgb2YgYXV0aG9yaXR5IHRvIHNldFxuICAgKiBAcGFyYW0gY3VycmVudEF1dGhvcml0eSBDdXJyZW50IGF1dGhvcml0eSBvZiB0aGUgYWNjb3VudFxuICAgKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYGN1cnJlbnRBdXRob3JpdHlgIGlzIGEgbXVsdGlTaWdcbiAgICovXG5cblxuICBhc3luYyBzZXRBdXRob3JpdHkoYWNjb3VudCwgbmV3QXV0aG9yaXR5LCBhdXRob3JpdHlUeXBlLCBjdXJyZW50QXV0aG9yaXR5LCBtdWx0aVNpZ25lcnMpIHtcbiAgICBsZXQgY3VycmVudEF1dGhvcml0eVB1YmxpY0tleTtcbiAgICBsZXQgc2lnbmVycztcblxuICAgIGlmIChpc0FjY291bnQoY3VycmVudEF1dGhvcml0eSkpIHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlQdWJsaWNLZXkgPSBjdXJyZW50QXV0aG9yaXR5LnB1YmxpY0tleTtcbiAgICAgIHNpZ25lcnMgPSBbY3VycmVudEF1dGhvcml0eV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlQdWJsaWNLZXkgPSBjdXJyZW50QXV0aG9yaXR5O1xuICAgICAgc2lnbmVycyA9IG11bHRpU2lnbmVycztcbiAgICB9XG5cbiAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCdTZXRBdXRob3JpdHknLCB0aGlzLmNvbm5lY3Rpb24sIG5ldyBUcmFuc2FjdGlvbigpLmFkZChUb2tlbi5jcmVhdGVTZXRBdXRob3JpdHlJbnN0cnVjdGlvbih0aGlzLnByb2dyYW1JZCwgYWNjb3VudCwgbmV3QXV0aG9yaXR5LCBhdXRob3JpdHlUeXBlLCBjdXJyZW50QXV0aG9yaXR5UHVibGljS2V5LCBtdWx0aVNpZ25lcnMpKSwgdGhpcy5wYXllciwgLi4uc2lnbmVycyk7XG4gIH1cbiAgLyoqXG4gICAqIE1pbnQgbmV3IHRva2Vuc1xuICAgKlxuICAgKiBAcGFyYW0gZGVzdCBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50IHRvIG1pbnQgdG9cbiAgICogQHBhcmFtIGF1dGhvcml0eSBNaW50aW5nIGF1dGhvcml0eVxuICAgKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYGF1dGhvcml0eWAgaXMgYSBtdWx0aVNpZ1xuICAgKiBAcGFyYW0gYW1vdW50IEFtb3VudCB0byBtaW50XG4gICAqL1xuXG5cbiAgYXN5bmMgbWludFRvKGRlc3QsIGF1dGhvcml0eSwgbXVsdGlTaWduZXJzLCBhbW91bnQpIHtcbiAgICBsZXQgb3duZXJQdWJsaWNLZXk7XG4gICAgbGV0IHNpZ25lcnM7XG5cbiAgICBpZiAoaXNBY2NvdW50KGF1dGhvcml0eSkpIHtcbiAgICAgIG93bmVyUHVibGljS2V5ID0gYXV0aG9yaXR5LnB1YmxpY0tleTtcbiAgICAgIHNpZ25lcnMgPSBbYXV0aG9yaXR5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duZXJQdWJsaWNLZXkgPSBhdXRob3JpdHk7XG4gICAgICBzaWduZXJzID0gbXVsdGlTaWduZXJzO1xuICAgIH1cblxuICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oJ01pbnRUbycsIHRoaXMuY29ubmVjdGlvbiwgbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFRva2VuLmNyZWF0ZU1pbnRUb0luc3RydWN0aW9uKHRoaXMucHJvZ3JhbUlkLCB0aGlzLnB1YmxpY0tleSwgZGVzdCwgb3duZXJQdWJsaWNLZXksIG11bHRpU2lnbmVycywgYW1vdW50KSksIHRoaXMucGF5ZXIsIC4uLnNpZ25lcnMpO1xuICB9XG4gIC8qKlxuICAgKiBCdXJuIHRva2Vuc1xuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCBBY2NvdW50IHRvIGJ1cm4gdG9rZW5zIGZyb21cbiAgICogQHBhcmFtIG93bmVyIEFjY291bnQgb3duZXJcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBvd25lcmAgaXMgYSBtdWx0aVNpZ1xuICAgKiBAcGFyYW0gYW1vdW50IEFtb3VudCB0byBidXJuXG4gICAqL1xuXG5cbiAgYXN5bmMgYnVybihhY2NvdW50LCBvd25lciwgbXVsdGlTaWduZXJzLCBhbW91bnQpIHtcbiAgICBsZXQgb3duZXJQdWJsaWNLZXk7XG4gICAgbGV0IHNpZ25lcnM7XG5cbiAgICBpZiAoaXNBY2NvdW50KG93bmVyKSkge1xuICAgICAgb3duZXJQdWJsaWNLZXkgPSBvd25lci5wdWJsaWNLZXk7XG4gICAgICBzaWduZXJzID0gW293bmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duZXJQdWJsaWNLZXkgPSBvd25lcjtcbiAgICAgIHNpZ25lcnMgPSBtdWx0aVNpZ25lcnM7XG4gICAgfVxuXG4gICAgYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbignQnVybicsIHRoaXMuY29ubmVjdGlvbiwgbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFRva2VuLmNyZWF0ZUJ1cm5JbnN0cnVjdGlvbih0aGlzLnByb2dyYW1JZCwgdGhpcy5wdWJsaWNLZXksIGFjY291bnQsIG93bmVyUHVibGljS2V5LCBtdWx0aVNpZ25lcnMsIGFtb3VudCkpLCB0aGlzLnBheWVyLCAuLi5zaWduZXJzKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCBBY2NvdW50IHRvIGNsb3NlXG4gICAqIEBwYXJhbSBkZXN0IEFjY291bnQgdG8gcmVjZWl2ZSB0aGUgcmVtYWluaW5nIGJhbGFuY2Ugb2YgdGhlIGNsb3NlZCBhY2NvdW50XG4gICAqIEBwYXJhbSBhdXRob3JpdHkgQXV0aG9yaXR5IHdoaWNoIGlzIGFsbG93ZWQgdG8gY2xvc2UgdGhlIGFjY291bnRcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBhdXRob3JpdHlgIGlzIGEgbXVsdGlTaWdcbiAgICovXG5cblxuICBhc3luYyBjbG9zZUFjY291bnQoYWNjb3VudCwgZGVzdCwgYXV0aG9yaXR5LCBtdWx0aVNpZ25lcnMpIHtcbiAgICBsZXQgYXV0aG9yaXR5UHVibGljS2V5O1xuICAgIGxldCBzaWduZXJzO1xuXG4gICAgaWYgKGlzQWNjb3VudChhdXRob3JpdHkpKSB7XG4gICAgICBhdXRob3JpdHlQdWJsaWNLZXkgPSBhdXRob3JpdHkucHVibGljS2V5O1xuICAgICAgc2lnbmVycyA9IFthdXRob3JpdHldO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdXRob3JpdHlQdWJsaWNLZXkgPSBhdXRob3JpdHk7XG4gICAgICBzaWduZXJzID0gbXVsdGlTaWduZXJzO1xuICAgIH1cblxuICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oJ0Nsb3NlQWNjb3VudCcsIHRoaXMuY29ubmVjdGlvbiwgbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFRva2VuLmNyZWF0ZUNsb3NlQWNjb3VudEluc3RydWN0aW9uKHRoaXMucHJvZ3JhbUlkLCBhY2NvdW50LCBkZXN0LCBhdXRob3JpdHlQdWJsaWNLZXksIG11bHRpU2lnbmVycykpLCB0aGlzLnBheWVyLCAuLi5zaWduZXJzKTtcbiAgfVxuICAvKipcbiAgICogRnJlZXplIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIGFjY291bnQgQWNjb3VudCB0byBmcmVlemVcbiAgICogQHBhcmFtIGF1dGhvcml0eSBUaGUgbWludCBmcmVlemUgYXV0aG9yaXR5XG4gICAqIEBwYXJhbSBtdWx0aVNpZ25lcnMgU2lnbmluZyBhY2NvdW50cyBpZiBgYXV0aG9yaXR5YCBpcyBhIG11bHRpU2lnXG4gICAqL1xuXG5cbiAgYXN5bmMgZnJlZXplQWNjb3VudChhY2NvdW50LCBhdXRob3JpdHksIG11bHRpU2lnbmVycykge1xuICAgIGxldCBhdXRob3JpdHlQdWJsaWNLZXk7XG4gICAgbGV0IHNpZ25lcnM7XG5cbiAgICBpZiAoaXNBY2NvdW50KGF1dGhvcml0eSkpIHtcbiAgICAgIGF1dGhvcml0eVB1YmxpY0tleSA9IGF1dGhvcml0eS5wdWJsaWNLZXk7XG4gICAgICBzaWduZXJzID0gW2F1dGhvcml0eV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF1dGhvcml0eVB1YmxpY0tleSA9IGF1dGhvcml0eTtcbiAgICAgIHNpZ25lcnMgPSBtdWx0aVNpZ25lcnM7XG4gICAgfVxuXG4gICAgYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbignRnJlZXplQWNjb3VudCcsIHRoaXMuY29ubmVjdGlvbiwgbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFRva2VuLmNyZWF0ZUZyZWV6ZUFjY291bnRJbnN0cnVjdGlvbih0aGlzLnByb2dyYW1JZCwgYWNjb3VudCwgdGhpcy5wdWJsaWNLZXksIGF1dGhvcml0eVB1YmxpY0tleSwgbXVsdGlTaWduZXJzKSksIHRoaXMucGF5ZXIsIC4uLnNpZ25lcnMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGF3IGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIGFjY291bnQgQWNjb3VudCB0byB0aGF3XG4gICAqIEBwYXJhbSBhdXRob3JpdHkgVGhlIG1pbnQgZnJlZXplIGF1dGhvcml0eVxuICAgKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYGF1dGhvcml0eWAgaXMgYSBtdWx0aVNpZ1xuICAgKi9cblxuXG4gIGFzeW5jIHRoYXdBY2NvdW50KGFjY291bnQsIGF1dGhvcml0eSwgbXVsdGlTaWduZXJzKSB7XG4gICAgbGV0IGF1dGhvcml0eVB1YmxpY0tleTtcbiAgICBsZXQgc2lnbmVycztcblxuICAgIGlmIChpc0FjY291bnQoYXV0aG9yaXR5KSkge1xuICAgICAgYXV0aG9yaXR5UHVibGljS2V5ID0gYXV0aG9yaXR5LnB1YmxpY0tleTtcbiAgICAgIHNpZ25lcnMgPSBbYXV0aG9yaXR5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXV0aG9yaXR5UHVibGljS2V5ID0gYXV0aG9yaXR5O1xuICAgICAgc2lnbmVycyA9IG11bHRpU2lnbmVycztcbiAgICB9XG5cbiAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCdUaGF3QWNjb3VudCcsIHRoaXMuY29ubmVjdGlvbiwgbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFRva2VuLmNyZWF0ZVRoYXdBY2NvdW50SW5zdHJ1Y3Rpb24odGhpcy5wcm9ncmFtSWQsIGFjY291bnQsIHRoaXMucHVibGljS2V5LCBhdXRob3JpdHlQdWJsaWNLZXksIG11bHRpU2lnbmVycykpLCB0aGlzLnBheWVyLCAuLi5zaWduZXJzKTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmZXIgdG9rZW5zIHRvIGFub3RoZXIgYWNjb3VudCwgYXNzZXJ0aW5nIHRoZSB0b2tlbiBtaW50IGFuZCBkZWNpbWFsc1xuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIFNvdXJjZSBhY2NvdW50XG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBhY2NvdW50XG4gICAqIEBwYXJhbSBvd25lciBPd25lciBvZiB0aGUgc291cmNlIGFjY291bnRcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBvd25lcmAgaXMgYSBtdWx0aVNpZ1xuICAgKiBAcGFyYW0gYW1vdW50IE51bWJlciBvZiB0b2tlbnMgdG8gdHJhbnNmZXJcbiAgICogQHBhcmFtIGRlY2ltYWxzIE51bWJlciBvZiBkZWNpbWFscyBpbiB0cmFuc2ZlciBhbW91bnRcbiAgICovXG5cblxuICBhc3luYyB0cmFuc2ZlckNoZWNrZWQoc291cmNlLCBkZXN0aW5hdGlvbiwgb3duZXIsIG11bHRpU2lnbmVycywgYW1vdW50LCBkZWNpbWFscykge1xuICAgIGxldCBvd25lclB1YmxpY0tleTtcbiAgICBsZXQgc2lnbmVycztcblxuICAgIGlmIChpc0FjY291bnQob3duZXIpKSB7XG4gICAgICBvd25lclB1YmxpY0tleSA9IG93bmVyLnB1YmxpY0tleTtcbiAgICAgIHNpZ25lcnMgPSBbb3duZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25lclB1YmxpY0tleSA9IG93bmVyO1xuICAgICAgc2lnbmVycyA9IG11bHRpU2lnbmVycztcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbignVHJhbnNmZXJDaGVja2VkJywgdGhpcy5jb25uZWN0aW9uLCBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoVG9rZW4uY3JlYXRlVHJhbnNmZXJDaGVja2VkSW5zdHJ1Y3Rpb24odGhpcy5wcm9ncmFtSWQsIHNvdXJjZSwgdGhpcy5wdWJsaWNLZXksIGRlc3RpbmF0aW9uLCBvd25lclB1YmxpY0tleSwgbXVsdGlTaWduZXJzLCBhbW91bnQsIGRlY2ltYWxzKSksIHRoaXMucGF5ZXIsIC4uLnNpZ25lcnMpO1xuICB9XG4gIC8qKlxuICAgKiBHcmFudCBhIHRoaXJkLXBhcnR5IHBlcm1pc3Npb24gdG8gdHJhbnNmZXIgdXAgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdG9rZW5zIGZyb20gYW4gYWNjb3VudCxcbiAgICogYXNzZXJ0aW5nIHRoZSB0b2tlbiBtaW50IGFuZCBkZWNpbWFsc1xuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50XG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSBBY2NvdW50IGF1dGhvcml6ZWQgdG8gcGVyZm9ybSBhIHRyYW5zZmVyIHRva2VucyBmcm9tIHRoZSBzb3VyY2UgYWNjb3VudFxuICAgKiBAcGFyYW0gb3duZXIgT3duZXIgb2YgdGhlIHNvdXJjZSBhY2NvdW50XG4gICAqIEBwYXJhbSBtdWx0aVNpZ25lcnMgU2lnbmluZyBhY2NvdW50cyBpZiBgb3duZXJgIGlzIGEgbXVsdGlTaWdcbiAgICogQHBhcmFtIGFtb3VudCBNYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgdGhlIGRlbGVnYXRlIG1heSB0cmFuc2ZlclxuICAgKiBAcGFyYW0gZGVjaW1hbHMgTnVtYmVyIG9mIGRlY2ltYWxzIGluIGFwcHJvdmUgYW1vdW50XG4gICAqL1xuXG5cbiAgYXN5bmMgYXBwcm92ZUNoZWNrZWQoYWNjb3VudCwgZGVsZWdhdGUsIG93bmVyLCBtdWx0aVNpZ25lcnMsIGFtb3VudCwgZGVjaW1hbHMpIHtcbiAgICBsZXQgb3duZXJQdWJsaWNLZXk7XG4gICAgbGV0IHNpZ25lcnM7XG5cbiAgICBpZiAoaXNBY2NvdW50KG93bmVyKSkge1xuICAgICAgb3duZXJQdWJsaWNLZXkgPSBvd25lci5wdWJsaWNLZXk7XG4gICAgICBzaWduZXJzID0gW293bmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duZXJQdWJsaWNLZXkgPSBvd25lcjtcbiAgICAgIHNpZ25lcnMgPSBtdWx0aVNpZ25lcnM7XG4gICAgfVxuXG4gICAgYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbignQXBwcm92ZUNoZWNrZWQnLCB0aGlzLmNvbm5lY3Rpb24sIG5ldyBUcmFuc2FjdGlvbigpLmFkZChUb2tlbi5jcmVhdGVBcHByb3ZlQ2hlY2tlZEluc3RydWN0aW9uKHRoaXMucHJvZ3JhbUlkLCBhY2NvdW50LCB0aGlzLnB1YmxpY0tleSwgZGVsZWdhdGUsIG93bmVyUHVibGljS2V5LCBtdWx0aVNpZ25lcnMsIGFtb3VudCwgZGVjaW1hbHMpKSwgdGhpcy5wYXllciwgLi4uc2lnbmVycyk7XG4gIH1cbiAgLyoqXG4gICAqIE1pbnQgbmV3IHRva2VucywgYXNzZXJ0aW5nIHRoZSB0b2tlbiBtaW50IGFuZCBkZWNpbWFsc1xuICAgKlxuICAgKiBAcGFyYW0gZGVzdCBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50IHRvIG1pbnQgdG9cbiAgICogQHBhcmFtIGF1dGhvcml0eSBNaW50aW5nIGF1dGhvcml0eVxuICAgKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYGF1dGhvcml0eWAgaXMgYSBtdWx0aVNpZ1xuICAgKiBAcGFyYW0gYW1vdW50IEFtb3VudCB0byBtaW50XG4gICAqIEBwYXJhbSBkZWNpbWFscyBOdW1iZXIgb2YgZGVjaW1hbHMgaW4gYW1vdW50IHRvIG1pbnRcbiAgICovXG5cblxuICBhc3luYyBtaW50VG9DaGVja2VkKGRlc3QsIGF1dGhvcml0eSwgbXVsdGlTaWduZXJzLCBhbW91bnQsIGRlY2ltYWxzKSB7XG4gICAgbGV0IG93bmVyUHVibGljS2V5O1xuICAgIGxldCBzaWduZXJzO1xuXG4gICAgaWYgKGlzQWNjb3VudChhdXRob3JpdHkpKSB7XG4gICAgICBvd25lclB1YmxpY0tleSA9IGF1dGhvcml0eS5wdWJsaWNLZXk7XG4gICAgICBzaWduZXJzID0gW2F1dGhvcml0eV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bmVyUHVibGljS2V5ID0gYXV0aG9yaXR5O1xuICAgICAgc2lnbmVycyA9IG11bHRpU2lnbmVycztcbiAgICB9XG5cbiAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCdNaW50VG9DaGVja2VkJywgdGhpcy5jb25uZWN0aW9uLCBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoVG9rZW4uY3JlYXRlTWludFRvQ2hlY2tlZEluc3RydWN0aW9uKHRoaXMucHJvZ3JhbUlkLCB0aGlzLnB1YmxpY0tleSwgZGVzdCwgb3duZXJQdWJsaWNLZXksIG11bHRpU2lnbmVycywgYW1vdW50LCBkZWNpbWFscykpLCB0aGlzLnBheWVyLCAuLi5zaWduZXJzKTtcbiAgfVxuICAvKipcbiAgICogQnVybiB0b2tlbnMsIGFzc2VydGluZyB0aGUgdG9rZW4gbWludCBhbmQgZGVjaW1hbHNcbiAgICpcbiAgICogQHBhcmFtIGFjY291bnQgQWNjb3VudCB0byBidXJuIHRva2VucyBmcm9tXG4gICAqIEBwYXJhbSBvd25lciBBY2NvdW50IG93bmVyXG4gICAqIEBwYXJhbSBtdWx0aVNpZ25lcnMgU2lnbmluZyBhY2NvdW50cyBpZiBgb3duZXJgIGlzIGEgbXVsdGlTaWdcbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgdG8gYnVyblxuICAgKiBAcGFyYW0gZGVjaW1hbHMgTnVtYmVyIG9mIGRlY2ltYWxzIGluIGFtb3VudCB0byBidXJuXG4gICAqL1xuXG5cbiAgYXN5bmMgYnVybkNoZWNrZWQoYWNjb3VudCwgb3duZXIsIG11bHRpU2lnbmVycywgYW1vdW50LCBkZWNpbWFscykge1xuICAgIGxldCBvd25lclB1YmxpY0tleTtcbiAgICBsZXQgc2lnbmVycztcblxuICAgIGlmIChpc0FjY291bnQob3duZXIpKSB7XG4gICAgICBvd25lclB1YmxpY0tleSA9IG93bmVyLnB1YmxpY0tleTtcbiAgICAgIHNpZ25lcnMgPSBbb3duZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25lclB1YmxpY0tleSA9IG93bmVyO1xuICAgICAgc2lnbmVycyA9IG11bHRpU2lnbmVycztcbiAgICB9XG5cbiAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCdCdXJuQ2hlY2tlZCcsIHRoaXMuY29ubmVjdGlvbiwgbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFRva2VuLmNyZWF0ZUJ1cm5DaGVja2VkSW5zdHJ1Y3Rpb24odGhpcy5wcm9ncmFtSWQsIHRoaXMucHVibGljS2V5LCBhY2NvdW50LCBvd25lclB1YmxpY0tleSwgbXVsdGlTaWduZXJzLCBhbW91bnQsIGRlY2ltYWxzKSksIHRoaXMucGF5ZXIsIC4uLnNpZ25lcnMpO1xuICB9XG4gIC8qKlxuICAgKiBTeW5jIGFtb3VudCBpbiBuYXRpdmUgU1BMIHRva2VuIGFjY291bnQgdG8gdW5kZXJseWluZyBsYW1wb3J0c1xuICAgKlxuICAgKiBAcGFyYW0gbmF0aXZlQWNjb3VudCBBY2NvdW50IHRvIHN5bmNcbiAgICovXG5cblxuICBhc3luYyBzeW5jTmF0aXZlKG5hdGl2ZUFjY291bnQpIHtcbiAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCdTeW5jTmF0aXZlJywgdGhpcy5jb25uZWN0aW9uLCBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoVG9rZW4uY3JlYXRlU3luY05hdGl2ZUluc3RydWN0aW9uKHRoaXMucHJvZ3JhbUlkLCBuYXRpdmVBY2NvdW50KSksIHRoaXMucGF5ZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gSW5pdGlhbGl6ZU1pbnQgaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHByb2dyYW1JZCBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gICAqIEBwYXJhbSBtaW50IFRva2VuIG1pbnQgYWNjb3VudFxuICAgKiBAcGFyYW0gZGVjaW1hbHMgTnVtYmVyIG9mIGRlY2ltYWxzIGluIHRva2VuIGFjY291bnQgYW1vdW50c1xuICAgKiBAcGFyYW0gbWludEF1dGhvcml0eSBNaW50aW5nIGF1dGhvcml0eVxuICAgKiBAcGFyYW0gZnJlZXplQXV0aG9yaXR5IE9wdGlvbmFsIGF1dGhvcml0eSB0aGF0IGNhbiBmcmVlemUgdG9rZW4gYWNjb3VudHNcbiAgICovXG5cblxuICBzdGF0aWMgY3JlYXRlSW5pdE1pbnRJbnN0cnVjdGlvbihwcm9ncmFtSWQsIG1pbnQsIGRlY2ltYWxzLCBtaW50QXV0aG9yaXR5LCBmcmVlemVBdXRob3JpdHkpIHtcbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IG1pbnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGNvbnN0IGNvbW1hbmREYXRhTGF5b3V0ID0gc3RydWN0KFt1OCgnaW5zdHJ1Y3Rpb24nKSwgdTgoJ2RlY2ltYWxzJyksIHB1YmxpY0tleSgnbWludEF1dGhvcml0eScpLCB1OCgnb3B0aW9uJyksIHB1YmxpY0tleSgnZnJlZXplQXV0aG9yaXR5JyldKTtcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoMTAyNCk7XG4gICAge1xuICAgICAgY29uc3QgZW5jb2RlTGVuZ3RoID0gY29tbWFuZERhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDAsXG4gICAgICAgIC8vIEluaXRpYWxpemVNaW50IGluc3RydWN0aW9uXG4gICAgICAgIGRlY2ltYWxzLFxuICAgICAgICBtaW50QXV0aG9yaXR5OiBwdWJrZXlUb0J1ZmZlcihtaW50QXV0aG9yaXR5KSxcbiAgICAgICAgb3B0aW9uOiBmcmVlemVBdXRob3JpdHkgPT09IG51bGwgPyAwIDogMSxcbiAgICAgICAgZnJlZXplQXV0aG9yaXR5OiBwdWJrZXlUb0J1ZmZlcihmcmVlemVBdXRob3JpdHkgfHwgbmV3IFB1YmxpY0tleSgwKSlcbiAgICAgIH0sIGRhdGEpO1xuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZW5jb2RlTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBJbml0aWFsaXplQWNjb3VudCBpbnN0cnVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAgICogQHBhcmFtIG1pbnQgVG9rZW4gbWludCBhY2NvdW50XG4gICAqIEBwYXJhbSBhY2NvdW50IE5ldyBhY2NvdW50XG4gICAqIEBwYXJhbSBvd25lciBPd25lciBvZiB0aGUgbmV3IGFjY291bnRcbiAgICovXG5cblxuICBzdGF0aWMgY3JlYXRlSW5pdEFjY291bnRJbnN0cnVjdGlvbihwcm9ncmFtSWQsIG1pbnQsIGFjY291bnQsIG93bmVyKSB7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IGFjY291bnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBtaW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgY29uc3QgZGF0YUxheW91dCA9IHN0cnVjdChbdTgoJ2luc3RydWN0aW9uJyldKTtcbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgIGluc3RydWN0aW9uOiAxIC8vIEluaXRpYWxpemVBY2NvdW50IGluc3RydWN0aW9uXG5cbiAgICB9LCBkYXRhKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgVHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHByb2dyYW1JZCBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gICAqIEBwYXJhbSBzb3VyY2UgU291cmNlIGFjY291bnRcbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIGFjY291bnRcbiAgICogQHBhcmFtIG93bmVyIE93bmVyIG9mIHRoZSBzb3VyY2UgYWNjb3VudFxuICAgKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYGF1dGhvcml0eWAgaXMgYSBtdWx0aVNpZ1xuICAgKiBAcGFyYW0gYW1vdW50IE51bWJlciBvZiB0b2tlbnMgdG8gdHJhbnNmZXJcbiAgICovXG5cblxuICBzdGF0aWMgY3JlYXRlVHJhbnNmZXJJbnN0cnVjdGlvbihwcm9ncmFtSWQsIHNvdXJjZSwgZGVzdGluYXRpb24sIG93bmVyLCBtdWx0aVNpZ25lcnMsIGFtb3VudCkge1xuICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBzdHJ1Y3QoW3U4KCdpbnN0cnVjdGlvbicpLCB1aW50NjQoJ2Ftb3VudCcpXSk7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoZGF0YUxheW91dC5zcGFuKTtcbiAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICBpbnN0cnVjdGlvbjogMyxcbiAgICAgIC8vIFRyYW5zZmVyIGluc3RydWN0aW9uXG4gICAgICBhbW91bnQ6IG5ldyB1NjQoYW1vdW50KS50b0J1ZmZlcigpXG4gICAgfSwgZGF0YSk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzb3VyY2UsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBkZXN0aW5hdGlvbixcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcblxuICAgIGlmIChtdWx0aVNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG11bHRpU2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHNpZ25lci5wdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBBcHByb3ZlIGluc3RydWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gYWNjb3VudCBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50XG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSBBY2NvdW50IGF1dGhvcml6ZWQgdG8gcGVyZm9ybSBhIHRyYW5zZmVyIG9mIHRva2VucyBmcm9tIHRoZSBzb3VyY2UgYWNjb3VudFxuICAgKiBAcGFyYW0gb3duZXIgT3duZXIgb2YgdGhlIHNvdXJjZSBhY2NvdW50XG4gICAqIEBwYXJhbSBtdWx0aVNpZ25lcnMgU2lnbmluZyBhY2NvdW50cyBpZiBgb3duZXJgIGlzIGEgbXVsdGlTaWdcbiAgICogQHBhcmFtIGFtb3VudCBNYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgdGhlIGRlbGVnYXRlIG1heSB0cmFuc2ZlclxuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVBcHByb3ZlSW5zdHJ1Y3Rpb24ocHJvZ3JhbUlkLCBhY2NvdW50LCBkZWxlZ2F0ZSwgb3duZXIsIG11bHRpU2lnbmVycywgYW1vdW50KSB7XG4gICAgY29uc3QgZGF0YUxheW91dCA9IHN0cnVjdChbdTgoJ2luc3RydWN0aW9uJyksIHVpbnQ2NCgnYW1vdW50JyldKTtcbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgIGluc3RydWN0aW9uOiA0LFxuICAgICAgLy8gQXBwcm92ZSBpbnN0cnVjdGlvblxuICAgICAgYW1vdW50OiBuZXcgdTY0KGFtb3VudCkudG9CdWZmZXIoKVxuICAgIH0sIGRhdGEpO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogYWNjb3VudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGRlbGVnYXRlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcblxuICAgIGlmIChtdWx0aVNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG11bHRpU2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHNpZ25lci5wdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIFJldm9rZSBpbnN0cnVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAgICogQHBhcmFtIGFjY291bnQgUHVibGljIGtleSBvZiB0aGUgYWNjb3VudFxuICAgKiBAcGFyYW0gb3duZXIgT3duZXIgb2YgdGhlIHNvdXJjZSBhY2NvdW50XG4gICAqIEBwYXJhbSBtdWx0aVNpZ25lcnMgU2lnbmluZyBhY2NvdW50cyBpZiBgb3duZXJgIGlzIGEgbXVsdGlTaWdcbiAgICovXG5cblxuICBzdGF0aWMgY3JlYXRlUmV2b2tlSW5zdHJ1Y3Rpb24ocHJvZ3JhbUlkLCBhY2NvdW50LCBvd25lciwgbXVsdGlTaWduZXJzKSB7XG4gICAgY29uc3QgZGF0YUxheW91dCA9IHN0cnVjdChbdTgoJ2luc3RydWN0aW9uJyldKTtcbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgIGluc3RydWN0aW9uOiA1IC8vIEFwcHJvdmUgaW5zdHJ1Y3Rpb25cblxuICAgIH0sIGRhdGEpO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogYWNjb3VudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcblxuICAgIGlmIChtdWx0aVNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG11bHRpU2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHNpZ25lci5wdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIFNldEF1dGhvcml0eSBpbnN0cnVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAgICogQHBhcmFtIGFjY291bnQgUHVibGljIGtleSBvZiB0aGUgYWNjb3VudFxuICAgKiBAcGFyYW0gbmV3QXV0aG9yaXR5IE5ldyBhdXRob3JpdHkgb2YgdGhlIGFjY291bnRcbiAgICogQHBhcmFtIGF1dGhvcml0eVR5cGUgVHlwZSBvZiBhdXRob3JpdHkgdG8gc2V0XG4gICAqIEBwYXJhbSBjdXJyZW50QXV0aG9yaXR5IEN1cnJlbnQgYXV0aG9yaXR5IG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICAgKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYGN1cnJlbnRBdXRob3JpdHlgIGlzIGEgbXVsdGlTaWdcbiAgICovXG5cblxuICBzdGF0aWMgY3JlYXRlU2V0QXV0aG9yaXR5SW5zdHJ1Y3Rpb24ocHJvZ3JhbUlkLCBhY2NvdW50LCBuZXdBdXRob3JpdHksIGF1dGhvcml0eVR5cGUsIGN1cnJlbnRBdXRob3JpdHksIG11bHRpU2lnbmVycykge1xuICAgIGNvbnN0IGNvbW1hbmREYXRhTGF5b3V0ID0gc3RydWN0KFt1OCgnaW5zdHJ1Y3Rpb24nKSwgdTgoJ2F1dGhvcml0eVR5cGUnKSwgdTgoJ29wdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml0eScpXSk7XG4gICAgbGV0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKDEwMjQpO1xuICAgIHtcbiAgICAgIGNvbnN0IGVuY29kZUxlbmd0aCA9IGNvbW1hbmREYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiA2LFxuICAgICAgICAvLyBTZXRBdXRob3JpdHkgaW5zdHJ1Y3Rpb25cbiAgICAgICAgYXV0aG9yaXR5VHlwZTogQXV0aG9yaXR5VHlwZUNvZGVzW2F1dGhvcml0eVR5cGVdLFxuICAgICAgICBvcHRpb246IG5ld0F1dGhvcml0eSA9PT0gbnVsbCA/IDAgOiAxLFxuICAgICAgICBuZXdBdXRob3JpdHk6IHB1YmtleVRvQnVmZmVyKG5ld0F1dGhvcml0eSB8fCBuZXcgUHVibGljS2V5KDApKVxuICAgICAgfSwgZGF0YSk7XG4gICAgICBkYXRhID0gZGF0YS5zbGljZSgwLCBlbmNvZGVMZW5ndGgpO1xuICAgIH1cbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IGFjY291bnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG5cbiAgICBpZiAobXVsdGlTaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXJyZW50QXV0aG9yaXR5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IGN1cnJlbnRBdXRob3JpdHksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbXVsdGlTaWduZXJzLmZvckVhY2goc2lnbmVyID0+IGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogc2lnbmVyLnB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgTWludFRvIGluc3RydWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gbWludCBQdWJsaWMga2V5IG9mIHRoZSBtaW50XG4gICAqIEBwYXJhbSBkZXN0IFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdG8gbWludCB0b1xuICAgKiBAcGFyYW0gYXV0aG9yaXR5IFRoZSBtaW50IGF1dGhvcml0eVxuICAgKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYGF1dGhvcml0eWAgaXMgYSBtdWx0aVNpZ1xuICAgKiBAcGFyYW0gYW1vdW50IEFtb3VudCB0byBtaW50XG4gICAqL1xuXG5cbiAgc3RhdGljIGNyZWF0ZU1pbnRUb0luc3RydWN0aW9uKHByb2dyYW1JZCwgbWludCwgZGVzdCwgYXV0aG9yaXR5LCBtdWx0aVNpZ25lcnMsIGFtb3VudCkge1xuICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBzdHJ1Y3QoW3U4KCdpbnN0cnVjdGlvbicpLCB1aW50NjQoJ2Ftb3VudCcpXSk7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoZGF0YUxheW91dC5zcGFuKTtcbiAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICBpbnN0cnVjdGlvbjogNyxcbiAgICAgIC8vIE1pbnRUbyBpbnN0cnVjdGlvblxuICAgICAgYW1vdW50OiBuZXcgdTY0KGFtb3VudCkudG9CdWZmZXIoKVxuICAgIH0sIGRhdGEpO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogbWludCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGRlc3QsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG5cbiAgICBpZiAobXVsdGlTaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpdHksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXR5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG11bHRpU2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHNpZ25lci5wdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIEJ1cm4gaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHByb2dyYW1JZCBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gICAqIEBwYXJhbSBtaW50IE1pbnQgZm9yIHRoZSBhY2NvdW50XG4gICAqIEBwYXJhbSBhY2NvdW50IEFjY291bnQgdG8gYnVybiB0b2tlbnMgZnJvbVxuICAgKiBAcGFyYW0gb3duZXIgT3duZXIgb2YgdGhlIGFjY291bnRcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBhdXRob3JpdHlgIGlzIGEgbXVsdGlTaWdcbiAgICogQHBhcmFtIGFtb3VudCBhbW91bnQgdG8gYnVyblxuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVCdXJuSW5zdHJ1Y3Rpb24ocHJvZ3JhbUlkLCBtaW50LCBhY2NvdW50LCBvd25lciwgbXVsdGlTaWduZXJzLCBhbW91bnQpIHtcbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gc3RydWN0KFt1OCgnaW5zdHJ1Y3Rpb24nKSwgdWludDY0KCdhbW91bnQnKV0pO1xuICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgaW5zdHJ1Y3Rpb246IDgsXG4gICAgICAvLyBCdXJuIGluc3RydWN0aW9uXG4gICAgICBhbW91bnQ6IG5ldyB1NjQoYW1vdW50KS50b0J1ZmZlcigpXG4gICAgfSwgZGF0YSk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBhY2NvdW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogbWludCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcblxuICAgIGlmIChtdWx0aVNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG11bHRpU2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHNpZ25lci5wdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIENsb3NlIGluc3RydWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gYWNjb3VudCBBY2NvdW50IHRvIGNsb3NlXG4gICAqIEBwYXJhbSBkZXN0IEFjY291bnQgdG8gcmVjZWl2ZSB0aGUgcmVtYWluaW5nIGJhbGFuY2Ugb2YgdGhlIGNsb3NlZCBhY2NvdW50XG4gICAqIEBwYXJhbSBhdXRob3JpdHkgQWNjb3VudCBDbG9zZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBvd25lcmAgaXMgYSBtdWx0aVNpZ1xuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVDbG9zZUFjY291bnRJbnN0cnVjdGlvbihwcm9ncmFtSWQsIGFjY291bnQsIGRlc3QsIG93bmVyLCBtdWx0aVNpZ25lcnMpIHtcbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gc3RydWN0KFt1OCgnaW5zdHJ1Y3Rpb24nKV0pO1xuICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgaW5zdHJ1Y3Rpb246IDkgLy8gQ2xvc2VBY2NvdW50IGluc3RydWN0aW9uXG5cbiAgICB9LCBkYXRhKTtcbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IGFjY291bnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBkZXN0LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuXG4gICAgaWYgKG11bHRpU2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogb3duZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogb3duZXIsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbXVsdGlTaWduZXJzLmZvckVhY2goc2lnbmVyID0+IGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogc2lnbmVyLnB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgRnJlZXplIGluc3RydWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gYWNjb3VudCBBY2NvdW50IHRvIGZyZWV6ZVxuICAgKiBAcGFyYW0gbWludCBNaW50IGFjY291bnRcbiAgICogQHBhcmFtIGF1dGhvcml0eSBNaW50IGZyZWV6ZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBvd25lcmAgaXMgYSBtdWx0aVNpZ1xuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVGcmVlemVBY2NvdW50SW5zdHJ1Y3Rpb24ocHJvZ3JhbUlkLCBhY2NvdW50LCBtaW50LCBhdXRob3JpdHksIG11bHRpU2lnbmVycykge1xuICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBzdHJ1Y3QoW3U4KCdpbnN0cnVjdGlvbicpXSk7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoZGF0YUxheW91dC5zcGFuKTtcbiAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICBpbnN0cnVjdGlvbjogMTAgLy8gRnJlZXplQWNjb3VudCBpbnN0cnVjdGlvblxuXG4gICAgfSwgZGF0YSk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBhY2NvdW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogbWludCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG5cbiAgICBpZiAobXVsdGlTaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpdHksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXR5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG11bHRpU2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHNpZ25lci5wdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIFRoYXcgaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHByb2dyYW1JZCBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gICAqIEBwYXJhbSBhY2NvdW50IEFjY291bnQgdG8gdGhhd1xuICAgKiBAcGFyYW0gbWludCBNaW50IGFjY291bnRcbiAgICogQHBhcmFtIGF1dGhvcml0eSBNaW50IGZyZWV6ZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBvd25lcmAgaXMgYSBtdWx0aVNpZ1xuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVUaGF3QWNjb3VudEluc3RydWN0aW9uKHByb2dyYW1JZCwgYWNjb3VudCwgbWludCwgYXV0aG9yaXR5LCBtdWx0aVNpZ25lcnMpIHtcbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gc3RydWN0KFt1OCgnaW5zdHJ1Y3Rpb24nKV0pO1xuICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgaW5zdHJ1Y3Rpb246IDExIC8vIFRoYXdBY2NvdW50IGluc3RydWN0aW9uXG5cbiAgICB9LCBkYXRhKTtcbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IGFjY291bnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBtaW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcblxuICAgIGlmIChtdWx0aVNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml0eSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpdHksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbXVsdGlTaWduZXJzLmZvckVhY2goc2lnbmVyID0+IGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogc2lnbmVyLnB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgVHJhbnNmZXJDaGVja2VkIGluc3RydWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gc291cmNlIFNvdXJjZSBhY2NvdW50XG4gICAqIEBwYXJhbSBtaW50IE1pbnQgYWNjb3VudFxuICAgKiBAcGFyYW0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gYWNjb3VudFxuICAgKiBAcGFyYW0gb3duZXIgT3duZXIgb2YgdGhlIHNvdXJjZSBhY2NvdW50XG4gICAqIEBwYXJhbSBtdWx0aVNpZ25lcnMgU2lnbmluZyBhY2NvdW50cyBpZiBgYXV0aG9yaXR5YCBpcyBhIG11bHRpU2lnXG4gICAqIEBwYXJhbSBhbW91bnQgTnVtYmVyIG9mIHRva2VucyB0byB0cmFuc2ZlclxuICAgKiBAcGFyYW0gZGVjaW1hbHMgTnVtYmVyIG9mIGRlY2ltYWxzIGluIHRyYW5zZmVyIGFtb3VudFxuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvbihwcm9ncmFtSWQsIHNvdXJjZSwgbWludCwgZGVzdGluYXRpb24sIG93bmVyLCBtdWx0aVNpZ25lcnMsIGFtb3VudCwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gc3RydWN0KFt1OCgnaW5zdHJ1Y3Rpb24nKSwgdWludDY0KCdhbW91bnQnKSwgdTgoJ2RlY2ltYWxzJyldKTtcbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgIGluc3RydWN0aW9uOiAxMixcbiAgICAgIC8vIFRyYW5zZmVyQ2hlY2tlZCBpbnN0cnVjdGlvblxuICAgICAgYW1vdW50OiBuZXcgdTY0KGFtb3VudCkudG9CdWZmZXIoKSxcbiAgICAgIGRlY2ltYWxzXG4gICAgfSwgZGF0YSk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzb3VyY2UsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBtaW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGRlc3RpbmF0aW9uLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuXG4gICAgaWYgKG11bHRpU2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogb3duZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogb3duZXIsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbXVsdGlTaWduZXJzLmZvckVhY2goc2lnbmVyID0+IGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogc2lnbmVyLnB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIEFwcHJvdmVDaGVja2VkIGluc3RydWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gYWNjb3VudCBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50XG4gICAqIEBwYXJhbSBtaW50IE1pbnQgYWNjb3VudFxuICAgKiBAcGFyYW0gZGVsZWdhdGUgQWNjb3VudCBhdXRob3JpemVkIHRvIHBlcmZvcm0gYSB0cmFuc2ZlciBvZiB0b2tlbnMgZnJvbSB0aGUgc291cmNlIGFjY291bnRcbiAgICogQHBhcmFtIG93bmVyIE93bmVyIG9mIHRoZSBzb3VyY2UgYWNjb3VudFxuICAgKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYG93bmVyYCBpcyBhIG11bHRpU2lnXG4gICAqIEBwYXJhbSBhbW91bnQgTWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIHRoZSBkZWxlZ2F0ZSBtYXkgdHJhbnNmZXJcbiAgICogQHBhcmFtIGRlY2ltYWxzIE51bWJlciBvZiBkZWNpbWFscyBpbiBhcHByb3ZlIGFtb3VudFxuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVBcHByb3ZlQ2hlY2tlZEluc3RydWN0aW9uKHByb2dyYW1JZCwgYWNjb3VudCwgbWludCwgZGVsZWdhdGUsIG93bmVyLCBtdWx0aVNpZ25lcnMsIGFtb3VudCwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gc3RydWN0KFt1OCgnaW5zdHJ1Y3Rpb24nKSwgdWludDY0KCdhbW91bnQnKSwgdTgoJ2RlY2ltYWxzJyldKTtcbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgIGluc3RydWN0aW9uOiAxMyxcbiAgICAgIC8vIEFwcHJvdmVDaGVja2VkIGluc3RydWN0aW9uXG4gICAgICBhbW91bnQ6IG5ldyB1NjQoYW1vdW50KS50b0J1ZmZlcigpLFxuICAgICAgZGVjaW1hbHNcbiAgICB9LCBkYXRhKTtcbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IGFjY291bnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBtaW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGRlbGVnYXRlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcblxuICAgIGlmIChtdWx0aVNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG93bmVyLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG11bHRpU2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHNpZ25lci5wdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIE1pbnRUb0NoZWNrZWQgaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHByb2dyYW1JZCBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gICAqIEBwYXJhbSBtaW50IFB1YmxpYyBrZXkgb2YgdGhlIG1pbnRcbiAgICogQHBhcmFtIGRlc3QgUHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB0byBtaW50IHRvXG4gICAqIEBwYXJhbSBhdXRob3JpdHkgVGhlIG1pbnQgYXV0aG9yaXR5XG4gICAqIEBwYXJhbSBtdWx0aVNpZ25lcnMgU2lnbmluZyBhY2NvdW50cyBpZiBgYXV0aG9yaXR5YCBpcyBhIG11bHRpU2lnXG4gICAqIEBwYXJhbSBhbW91bnQgQW1vdW50IHRvIG1pbnRcbiAgICogQHBhcmFtIGRlY2ltYWxzIE51bWJlciBvZiBkZWNpbWFscyBpbiBhbW91bnQgdG8gbWludFxuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVNaW50VG9DaGVja2VkSW5zdHJ1Y3Rpb24ocHJvZ3JhbUlkLCBtaW50LCBkZXN0LCBhdXRob3JpdHksIG11bHRpU2lnbmVycywgYW1vdW50LCBkZWNpbWFscykge1xuICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBzdHJ1Y3QoW3U4KCdpbnN0cnVjdGlvbicpLCB1aW50NjQoJ2Ftb3VudCcpLCB1OCgnZGVjaW1hbHMnKV0pO1xuICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgaW5zdHJ1Y3Rpb246IDE0LFxuICAgICAgLy8gTWludFRvQ2hlY2tlZCBpbnN0cnVjdGlvblxuICAgICAgYW1vdW50OiBuZXcgdTY0KGFtb3VudCkudG9CdWZmZXIoKSxcbiAgICAgIGRlY2ltYWxzXG4gICAgfSwgZGF0YSk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBtaW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogZGVzdCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcblxuICAgIGlmIChtdWx0aVNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml0eSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpdHksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbXVsdGlTaWduZXJzLmZvckVhY2goc2lnbmVyID0+IGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogc2lnbmVyLnB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgQnVybkNoZWNrZWQgaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHByb2dyYW1JZCBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gICAqIEBwYXJhbSBtaW50IE1pbnQgZm9yIHRoZSBhY2NvdW50XG4gICAqIEBwYXJhbSBhY2NvdW50IEFjY291bnQgdG8gYnVybiB0b2tlbnMgZnJvbVxuICAgKiBAcGFyYW0gb3duZXIgT3duZXIgb2YgdGhlIGFjY291bnRcbiAgICogQHBhcmFtIG11bHRpU2lnbmVycyBTaWduaW5nIGFjY291bnRzIGlmIGBhdXRob3JpdHlgIGlzIGEgbXVsdGlTaWdcbiAgICogQHBhcmFtIGFtb3VudCBhbW91bnQgdG8gYnVyblxuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVCdXJuQ2hlY2tlZEluc3RydWN0aW9uKHByb2dyYW1JZCwgbWludCwgYWNjb3VudCwgb3duZXIsIG11bHRpU2lnbmVycywgYW1vdW50LCBkZWNpbWFscykge1xuICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBzdHJ1Y3QoW3U4KCdpbnN0cnVjdGlvbicpLCB1aW50NjQoJ2Ftb3VudCcpLCB1OCgnZGVjaW1hbHMnKV0pO1xuICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgaW5zdHJ1Y3Rpb246IDE1LFxuICAgICAgLy8gQnVybkNoZWNrZWQgaW5zdHJ1Y3Rpb25cbiAgICAgIGFtb3VudDogbmV3IHU2NChhbW91bnQpLnRvQnVmZmVyKCksXG4gICAgICBkZWNpbWFsc1xuICAgIH0sIGRhdGEpO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogYWNjb3VudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IG1pbnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG5cbiAgICBpZiAobXVsdGlTaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBvd25lcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBvd25lcixcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBtdWx0aVNpZ25lcnMuZm9yRWFjaChzaWduZXIgPT4ga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBzaWduZXIucHVibGljS2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogcHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBTeW5jTmF0aXZlIGluc3RydWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gbmF0aXZlQWNjb3VudCBBY2NvdW50IHRvIHN5bmMgbGFtcG9ydHMgZnJvbVxuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVTeW5jTmF0aXZlSW5zdHJ1Y3Rpb24ocHJvZ3JhbUlkLCBuYXRpdmVBY2NvdW50KSB7XG4gICAgY29uc3QgZGF0YUxheW91dCA9IHN0cnVjdChbdTgoJ2luc3RydWN0aW9uJyldKTtcbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgIGluc3RydWN0aW9uOiAxNyAvLyBTeW5jTmF0aXZlIGluc3RydWN0aW9uXG5cbiAgICB9LCBkYXRhKTtcbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IG5hdGl2ZUFjY291bnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhZGRyZXNzIGZvciB0aGUgYXNzb2NpYXRlZCB0b2tlbiBhY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBhc3NvY2lhdGVkUHJvZ3JhbUlkIFNQTCBBc3NvY2lhdGVkIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAgICogQHBhcmFtIG1pbnQgVG9rZW4gbWludCBhY2NvdW50XG4gICAqIEBwYXJhbSBvd25lciBPd25lciBvZiB0aGUgbmV3IGFjY291bnRcbiAgICogQHJldHVybiBQdWJsaWMga2V5IG9mIHRoZSBhc3NvY2lhdGVkIHRva2VuIGFjY291bnRcbiAgICovXG5cblxuICBzdGF0aWMgYXN5bmMgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzcyhhc3NvY2lhdGVkUHJvZ3JhbUlkLCBwcm9ncmFtSWQsIG1pbnQsIG93bmVyLCBhbGxvd093bmVyT2ZmQ3VydmUgPSBmYWxzZSkge1xuICAgIGlmICghYWxsb3dPd25lck9mZkN1cnZlICYmICFQdWJsaWNLZXkuaXNPbkN1cnZlKG93bmVyLnRvQnVmZmVyKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE93bmVyIGNhbm5vdCBzaWduOiAke293bmVyLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChhd2FpdCBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzKFtvd25lci50b0J1ZmZlcigpLCBwcm9ncmFtSWQudG9CdWZmZXIoKSwgbWludC50b0J1ZmZlcigpXSwgYXNzb2NpYXRlZFByb2dyYW1JZCkpWzBdO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgdGhlIEFzc29jaWF0ZWRUb2tlblByb2dyYW0gaW5zdHJ1Y3Rpb24gdG8gY3JlYXRlIHRoZSBhc3NvY2lhdGVkXG4gICAqIHRva2VuIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIGFzc29jaWF0ZWRQcm9ncmFtSWQgU1BMIEFzc29jaWF0ZWQgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICAgKiBAcGFyYW0gbWludCBUb2tlbiBtaW50IGFjY291bnRcbiAgICogQHBhcmFtIGFzc29jaWF0ZWRBY2NvdW50IE5ldyBhc3NvY2lhdGVkIGFjY291bnRcbiAgICogQHBhcmFtIG93bmVyIE93bmVyIG9mIHRoZSBuZXcgYWNjb3VudFxuICAgKiBAcGFyYW0gcGF5ZXIgUGF5ZXIgb2YgZmVlc1xuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50SW5zdHJ1Y3Rpb24oYXNzb2NpYXRlZFByb2dyYW1JZCwgcHJvZ3JhbUlkLCBtaW50LCBhc3NvY2lhdGVkQWNjb3VudCwgb3duZXIsIHBheWVyKSB7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoMCk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXllcixcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXNzb2NpYXRlZEFjY291bnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBvd25lcixcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBtaW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHByb2dyYW1JZCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiBhc3NvY2lhdGVkUHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0IHsgQVNTT0NJQVRFRF9UT0tFTl9QUk9HUkFNX0lELCBBY2NvdW50TGF5b3V0LCBNaW50TGF5b3V0LCBOQVRJVkVfTUlOVCwgVE9LRU5fUFJPR1JBTV9JRCwgVG9rZW4sIHU2NCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguYnJvd3Nlci5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@solana/spl-token/lib/index.browser.esm.js\n"));

/***/ }),

/***/ "./components/TokenBalance.tsx":
/*!*************************************!*\
  !*** ./components/TokenBalance.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solana_spl_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/spl-token */ \"./node_modules/@solana/spl-token/lib/index.browser.esm.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n// components/TokenBalance.tsx\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst TRENCOIN_MINT = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_3__.PublicKey(\"3WJYZL3npenDeutrnNHhGLpXCok3mqrmuxcLjWGCtirf\");\nconst TokenBalance = ()=>{\n    _s();\n    const { connection } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useConnection)();\n    const { publicKey } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useWallet)();\n    const [balance, setBalance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const fetchBalance = async ()=>{\n            if (!publicKey) return;\n            try {\n                const ata = await (0,_solana_spl_token__WEBPACK_IMPORTED_MODULE_2__.getAssociatedTokenAddress)(TRENCOIN_MINT, publicKey);\n                const accountInfo = await (0,_solana_spl_token__WEBPACK_IMPORTED_MODULE_2__.getAccount)(connection, ata);\n                const rawAmount = Number(accountInfo.amount);\n                const adjusted = rawAmount / 1000000; // Adjust based on decimals\n                setBalance(adjusted);\n            } catch (err) {\n                setBalance(0); // Probably doesn't have TC yet\n            }\n        };\n        fetchBalance();\n    }, [\n        connection,\n        publicKey\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n            children: [\n                \"TrenCoin Balance: \",\n                balance !== null ? \"\".concat(balance, \" TC\") : \"\"\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/lukegullekson/Desktop/tren-starter/components/TokenBalance.tsx\",\n            lineNumber: 37,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/lukegullekson/Desktop/tren-starter/components/TokenBalance.tsx\",\n        lineNumber: 36,\n        columnNumber: 5\n    }, undefined);\n};\n_s(TokenBalance, \"qAan6PbvOKrV3bhMcAtH0w48R6E=\", false, function() {\n    return [\n        _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useConnection,\n        _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useWallet\n    ];\n});\n_c = TokenBalance;\n/* harmony default export */ __webpack_exports__[\"default\"] = (TokenBalance);\nvar _c;\n$RefreshReg$(_c, \"TokenBalance\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1Rva2VuQmFsYW5jZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSw4QkFBOEI7OztBQUMwQztBQUM1QjtBQUlqQjtBQUNpQjtBQUU1QyxNQUFNTyxnQkFBZ0IsSUFBSUQsc0RBQVNBLENBQUM7QUFFcEMsTUFBTUUsZUFBZTs7SUFDbkIsTUFBTSxFQUFFQyxVQUFVLEVBQUUsR0FBR1QsMkVBQWFBO0lBQ3BDLE1BQU0sRUFBRVUsU0FBUyxFQUFFLEdBQUdULHVFQUFTQTtJQUMvQixNQUFNLENBQUNVLFNBQVNDLFdBQVcsR0FBR1QsK0NBQVFBLENBQWdCO0lBRXRERCxnREFBU0EsQ0FBQztRQUNSLE1BQU1XLGVBQWU7WUFDbkIsSUFBSSxDQUFDSCxXQUFXO1lBRWhCLElBQUk7Z0JBQ0YsTUFBTUksTUFBTSxNQUFNViw0RUFBeUJBLENBQUNHLGVBQWVHO2dCQUMzRCxNQUFNSyxjQUFjLE1BQU1WLDZEQUFVQSxDQUFDSSxZQUFZSztnQkFDakQsTUFBTUUsWUFBWUMsT0FBT0YsWUFBWUcsTUFBTTtnQkFDM0MsTUFBTUMsV0FBV0gsWUFBWSxTQUFXLDJCQUEyQjtnQkFDbkVKLFdBQVdPO1lBQ2IsRUFBRSxPQUFPQyxLQUFLO2dCQUNaUixXQUFXLElBQUksK0JBQStCO1lBQ2hEO1FBQ0Y7UUFFQUM7SUFDRixHQUFHO1FBQUNKO1FBQVlDO0tBQVU7SUFFMUIscUJBQ0UsOERBQUNXO2tCQUNDLDRFQUFDQzs7Z0JBQUc7Z0JBQW1CWCxZQUFZLE9BQU8sR0FBVyxPQUFSQSxTQUFRLFNBQU87Ozs7Ozs7Ozs7OztBQUdsRTtHQTVCTUg7O1FBQ21CUix1RUFBYUE7UUFDZEMsbUVBQVNBOzs7S0FGM0JPO0FBOEJOLCtEQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvVG9rZW5CYWxhbmNlLnRzeD9kYmFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbXBvbmVudHMvVG9rZW5CYWxhbmNlLnRzeFxuaW1wb3J0IHsgdXNlQ29ubmVjdGlvbiwgdXNlV2FsbGV0IH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzcyxcbiAgZ2V0QWNjb3VudFxufSBmcm9tICdAc29sYW5hL3NwbC10b2tlbic7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuXG5jb25zdCBUUkVOQ09JTl9NSU5UID0gbmV3IFB1YmxpY0tleSgnM1dKWVpMM25wZW5EZXV0cm5OSGhHTHBYQ29rM21xcm11eGNMaldHQ3RpcmYnKTtcblxuY29uc3QgVG9rZW5CYWxhbmNlID0gKCkgPT4ge1xuICBjb25zdCB7IGNvbm5lY3Rpb24gfSA9IHVzZUNvbm5lY3Rpb24oKTtcbiAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IHVzZVdhbGxldCgpO1xuICBjb25zdCBbYmFsYW5jZSwgc2V0QmFsYW5jZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGZldGNoQmFsYW5jZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghcHVibGljS2V5KSByZXR1cm47XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGF0YSA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3MoVFJFTkNPSU5fTUlOVCwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCBnZXRBY2NvdW50KGNvbm5lY3Rpb24sIGF0YSk7XG4gICAgICAgIGNvbnN0IHJhd0Ftb3VudCA9IE51bWJlcihhY2NvdW50SW5mby5hbW91bnQpO1xuICAgICAgICBjb25zdCBhZGp1c3RlZCA9IHJhd0Ftb3VudCAvIDFfMDAwXzAwMDsgLy8gQWRqdXN0IGJhc2VkIG9uIGRlY2ltYWxzXG4gICAgICAgIHNldEJhbGFuY2UoYWRqdXN0ZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldEJhbGFuY2UoMCk7IC8vIFByb2JhYmx5IGRvZXNuJ3QgaGF2ZSBUQyB5ZXRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZmV0Y2hCYWxhbmNlKCk7XG4gIH0sIFtjb25uZWN0aW9uLCBwdWJsaWNLZXldKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8aDM+VHJlbkNvaW4gQmFsYW5jZToge2JhbGFuY2UgIT09IG51bGwgPyBgJHtiYWxhbmNlfSBUQ2AgOiAn4oCUJ308L2gzPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVG9rZW5CYWxhbmNlO1xuIl0sIm5hbWVzIjpbInVzZUNvbm5lY3Rpb24iLCJ1c2VXYWxsZXQiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3MiLCJnZXRBY2NvdW50IiwiUHVibGljS2V5IiwiVFJFTkNPSU5fTUlOVCIsIlRva2VuQmFsYW5jZSIsImNvbm5lY3Rpb24iLCJwdWJsaWNLZXkiLCJiYWxhbmNlIiwic2V0QmFsYW5jZSIsImZldGNoQmFsYW5jZSIsImF0YSIsImFjY291bnRJbmZvIiwicmF3QW1vdW50IiwiTnVtYmVyIiwiYW1vdW50IiwiYWRqdXN0ZWQiLCJlcnIiLCJkaXYiLCJoMyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/TokenBalance.tsx\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperty(e, r, t) {\n  return (r = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7QUFDL0M7QUFDQSxjQUFjLDZEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcz9lYjRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0b1Byb3BlcnR5S2V5IGZyb20gXCIuL3RvUHJvcGVydHlLZXkuanNcIjtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5leHBvcnQgeyBfZGVmaW5lUHJvcGVydHkgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ toPrimitive; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7QUFDbEM7QUFDQSxrQkFBa0Isc0RBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1ByaW1pdGl2ZS5qcz8yYTI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmV4cG9ydCB7IHRvUHJpbWl0aXZlIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ toPropertyKey; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\");\n\n\nfunction toPropertyKey(t) {\n  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(t, \"string\");\n  return \"symbol\" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(i) ? i : i + \"\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Qcm9wZXJ0eUtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDUztBQUMzQztBQUNBLFVBQVUsMkRBQVc7QUFDckIscUJBQXFCLHNEQUFPO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzP2YxMTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5pbXBvcnQgdG9QcmltaXRpdmUgZnJvbSBcIi4vdG9QcmltaXRpdmUuanNcIjtcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxuZXhwb3J0IHsgdG9Qcm9wZXJ0eUtleSBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _typeof; }\n/* harmony export */ });\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcz81OTY0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5leHBvcnQgeyBfdHlwZW9mIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/typeof.js\n"));

/***/ })

}]);